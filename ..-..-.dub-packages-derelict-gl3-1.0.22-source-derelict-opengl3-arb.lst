       |/*
       |
       |Boost Software License - Version 1.0 - August 17th, 2003
       |
       |Permission is hereby granted, free of charge, to any person or organization
       |obtaining a copy of the software and accompanying documentation covered by
       |this license (the "Software") to use, reproduce, display, distribute,
       |execute, and transmit the Software, and to prepare derivative works of the
       |Software, and to permit third-parties to whom the Software is furnished to
       |do so, all subject to the following:
       |
       |The copyright notices in the Software and this entire statement, including
       |the above license grant, this restriction and the following disclaimer,
       |must be included in all copies of the Software, in whole or in part, and
       |all derivative works of the Software, unless such copies or derivative
       |works are solely in the form of machine-executable object code generated by
       |a source language processor.
       |
       |THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       |IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       |FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
       |SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
       |FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
       |ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
       |DEALINGS IN THE SOFTWARE.
       |
       |*/
       |module derelict.opengl3.arb;
       |
       |private {
       |    import derelict.util.system;
       |    import derelict.opengl3.types;
       |    import derelict.opengl3.constants;
       |    import derelict.opengl3.internal;
       |}
       |
       |// Part of ARB_sync
       |enum ulong GL_TIMEOUT_IGNORED  = 0xFFFFFFFFFFFFFFFF;
       |
       |enum : uint {
       |    // ARB_depth_buffer_float
       |    GL_DEPTH_COMPONENT32F             = 0x8CAC,
       |    GL_DEPTH32F_STENCIL8              = 0x8CAD,
       |    GL_FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD,
       |
       |    // ARB_framebuffer_object
       |    GL_INVALID_FRAMEBUFFER_OPERATION  = 0x0506,
       |    GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 0x8210,
       |    GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 0x8211,
       |    GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE = 0x8212,
       |    GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 0x8213,
       |    GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 0x8214,
       |    GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 0x8215,
       |    GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 0x8216,
       |    GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 0x8217,
       |    GL_FRAMEBUFFER_DEFAULT            = 0x8218,
       |    GL_FRAMEBUFFER_UNDEFINED          = 0x8219,
       |    GL_DEPTH_STENCIL_ATTACHMENT       = 0x821A,
       |    GL_MAX_RENDERBUFFER_SIZE          = 0x84E8,
       |    GL_DEPTH_STENCIL                  = 0x84F9,
       |    GL_UNSIGNED_INT_24_8              = 0x84FA,
       |    GL_DEPTH24_STENCIL8               = 0x88F0,
       |    GL_TEXTURE_STENCIL_SIZE           = 0x88F1,
       |    GL_TEXTURE_RED_TYPE               = 0x8C10,
       |    GL_TEXTURE_GREEN_TYPE             = 0x8C11,
       |    GL_TEXTURE_BLUE_TYPE              = 0x8C12,
       |    GL_TEXTURE_ALPHA_TYPE             = 0x8C13,
       |    GL_TEXTURE_DEPTH_TYPE             = 0x8C16,
       |    GL_UNSIGNED_NORMALIZED            = 0x8C17,
       |    GL_FRAMEBUFFER_BINDING            = 0x8CA6,
       |    GL_DRAW_FRAMEBUFFER_BINDING       = GL_FRAMEBUFFER_BINDING,
       |    GL_RENDERBUFFER_BINDING           = 0x8CA7,
       |    GL_READ_FRAMEBUFFER               = 0x8CA8,
       |    GL_DRAW_FRAMEBUFFER               = 0x8CA9,
       |    GL_READ_FRAMEBUFFER_BINDING       = 0x8CAA,
       |    GL_RENDERBUFFER_SAMPLES           = 0x8CAB,
       |    GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0,
       |    GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1,
       |    GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2,
       |    GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3,
       |    GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 0x8CD4,
       |    GL_FRAMEBUFFER_COMPLETE           = 0x8CD5,
       |    GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6,
       |    GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7,
       |    GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER = 0x8CDB,
       |    GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER = 0x8CDC,
       |    GL_FRAMEBUFFER_UNSUPPORTED        = 0x8CDD,
       |    GL_MAX_COLOR_ATTACHMENTS          = 0x8CDF,
       |    GL_COLOR_ATTACHMENT0              = 0x8CE0,
       |    GL_COLOR_ATTACHMENT1              = 0x8CE1,
       |    GL_COLOR_ATTACHMENT2              = 0x8CE2,
       |    GL_COLOR_ATTACHMENT3              = 0x8CE3,
       |    GL_COLOR_ATTACHMENT4              = 0x8CE4,
       |    GL_COLOR_ATTACHMENT5              = 0x8CE5,
       |    GL_COLOR_ATTACHMENT6              = 0x8CE6,
       |    GL_COLOR_ATTACHMENT7              = 0x8CE7,
       |    GL_COLOR_ATTACHMENT8              = 0x8CE8,
       |    GL_COLOR_ATTACHMENT9              = 0x8CE9,
       |    GL_COLOR_ATTACHMENT10             = 0x8CEA,
       |    GL_COLOR_ATTACHMENT11             = 0x8CEB,
       |    GL_COLOR_ATTACHMENT12             = 0x8CEC,
       |    GL_COLOR_ATTACHMENT13             = 0x8CED,
       |    GL_COLOR_ATTACHMENT14             = 0x8CEE,
       |    GL_COLOR_ATTACHMENT15             = 0x8CEF,
       |    GL_DEPTH_ATTACHMENT               = 0x8D00,
       |    GL_STENCIL_ATTACHMENT             = 0x8D20,
       |    GL_FRAMEBUFFER                    = 0x8D40,
       |    GL_RENDERBUFFER                   = 0x8D41,
       |    GL_RENDERBUFFER_WIDTH             = 0x8D42,
       |    GL_RENDERBUFFER_HEIGHT            = 0x8D43,
       |    GL_RENDERBUFFER_INTERNAL_FORMAT   = 0x8D44,
       |    GL_STENCIL_INDEX1                 = 0x8D46,
       |    GL_STENCIL_INDEX4                 = 0x8D47,
       |    GL_STENCIL_INDEX8                 = 0x8D48,
       |    GL_STENCIL_INDEX16                = 0x8D49,
       |    GL_RENDERBUFFER_RED_SIZE          = 0x8D50,
       |    GL_RENDERBUFFER_GREEN_SIZE        = 0x8D51,
       |    GL_RENDERBUFFER_BLUE_SIZE         = 0x8D52,
       |    GL_RENDERBUFFER_ALPHA_SIZE        = 0x8D53,
       |    GL_RENDERBUFFER_DEPTH_SIZE        = 0x8D54,
       |    GL_RENDERBUFFER_STENCIL_SIZE      = 0x8D55,
       |    GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 0x8D56,
       |    GL_MAX_SAMPLES                    = 0x8D57,
       |
       |    // ARB_framebuffer_sRGB
       |    GL_FRAMEBUFFER_SRGB               = 0x8DB9,
       |
       |    // ARB_geometry_shader4
       |    GL_LINES_ADJACENCY_ARB            = 0x000A,
       |    GL_LINE_STRIP_ADJACENCY_ARB       = 0x000B,
       |    GL_TRIANGLES_ADJACENCY_ARB        = 0x000C,
       |    GL_TRIANGLE_STRIP_ADJACENCY_ARB   = 0x000D,
       |    GL_PROGRAM_POINT_SIZE_ARB         = 0x8642,
       |    GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB = 0x8C29,
       |    GL_FRAMEBUFFER_ATTACHMENT_LAYERED_ARB = 0x8DA7,
       |    GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_ARB = 0x8DA8,
       |    GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB = 0x8DA9,
       |    GL_GEOMETRY_SHADER_ARB            = 0x8DD9,
       |    GL_GEOMETRY_VERTICES_OUT_ARB      = 0x8DDA,
       |    GL_GEOMETRY_INPUT_TYPE_ARB        = 0x8DDB,
       |    GL_GEOMETRY_OUTPUT_TYPE_ARB       = 0x8DDC,
       |    GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB = 0x8DDD,
       |    GL_MAX_VERTEX_VARYING_COMPONENTS_ARB = 0x8DDE,
       |    GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB = 0x8DDF,
       |    GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB = 0x8DE0,
       |    GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB = 0x8DE1,
       |
       |    // ARB_half_float_vertex
       |    GL_HALF_FLOAT                     = 0x140B,
       |
       |    // ARB_imaging
       |    GL_BLEND_COLOR = 0x8005,
       |    GL_BLEND_EQUATION = 0x8009,
       |
       |    // ARB_map_buffer_range
       |    GL_MAP_READ_BIT                   = 0x0001,
       |    GL_MAP_WRITE_BIT                  = 0x0002,
       |    GL_MAP_INVALIDATE_RANGE_BIT       = 0x0004,
       |    GL_MAP_INVALIDATE_BUFFER_BIT      = 0x0008,
       |    GL_MAP_FLUSH_EXPLICIT_BIT         = 0x0010,
       |    GL_MAP_UNSYNCHRONIZED_BIT         = 0x0020,
       |
       |    // ARB_texture_compression_rgtc
       |    GL_COMPRESSED_RED_RGTC1           = 0x8DBB,
       |    GL_COMPRESSED_SIGNED_RED_RGTC1    = 0x8DBC,
       |    GL_COMPRESSED_RG_RGTC2            = 0x8DBD,
       |    GL_COMPRESSED_SIGNED_RG_RGTC2     = 0x8DBE,
       |
       |    // ARB_texture_rg
       |    GL_RG                             = 0x8227,
       |    GL_RG_INTEGER                     = 0x8228,
       |    GL_R8                             = 0x8229,
       |    GL_R16                            = 0x822A,
       |    GL_RG8                            = 0x822B,
       |    GL_RG16                           = 0x822C,
       |    GL_R16F                           = 0x822D,
       |    GL_R32F                           = 0x822E,
       |    GL_RG16F                          = 0x822F,
       |    GL_RG32F                          = 0x8230,
       |    GL_R8I                            = 0x8231,
       |    GL_R8UI                           = 0x8232,
       |    GL_R16I                           = 0x8233,
       |    GL_R16UI                          = 0x8234,
       |    GL_R32I                           = 0x8235,
       |    GL_R32UI                          = 0x8236,
       |    GL_RG8I                           = 0x8237,
       |    GL_RG8UI                          = 0x8238,
       |    GL_RG16I                          = 0x8239,
       |    GL_RG16UI                         = 0x823A,
       |    GL_RG32I                          = 0x823B,
       |    GL_RG32UI                         = 0x823C,
       |
       |    // ARB_vertex_array_object
       |    GL_VERTEX_ARRAY_BINDING           = 0x85B5,
       |
       |    // ARB_uniform_buffer_object
       |    GL_UNIFORM_BUFFER                 = 0x8A11,
       |    GL_UNIFORM_BUFFER_BINDING         = 0x8A28,
       |    GL_UNIFORM_BUFFER_START           = 0x8A29,
       |    GL_UNIFORM_BUFFER_SIZE            = 0x8A2A,
       |    GL_MAX_VERTEX_UNIFORM_BLOCKS      = 0x8A2B,
       |    GL_MAX_GEOMETRY_UNIFORM_BLOCKS    = 0x8A2C,
       |    GL_MAX_FRAGMENT_UNIFORM_BLOCKS    = 0x8A2D,
       |    GL_MAX_COMBINED_UNIFORM_BLOCKS    = 0x8A2E,
       |    GL_MAX_UNIFORM_BUFFER_BINDINGS    = 0x8A2F,
       |    GL_MAX_UNIFORM_BLOCK_SIZE         = 0x8A30,
       |    GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 0x8A31,
       |    GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS = 0x8A32,
       |    GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 0x8A33,
       |    GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT = 0x8A34,
       |    GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = 0x8A35,
       |    GL_ACTIVE_UNIFORM_BLOCKS          = 0x8A36,
       |    GL_UNIFORM_TYPE                   = 0x8A37,
       |    GL_UNIFORM_SIZE                   = 0x8A38,
       |    GL_UNIFORM_NAME_LENGTH            = 0x8A39,
       |    GL_UNIFORM_BLOCK_INDEX            = 0x8A3A,
       |    GL_UNIFORM_OFFSET                 = 0x8A3B,
       |    GL_UNIFORM_ARRAY_STRIDE           = 0x8A3C,
       |    GL_UNIFORM_MATRIX_STRIDE          = 0x8A3D,
       |    GL_UNIFORM_IS_ROW_MAJOR           = 0x8A3E,
       |    GL_UNIFORM_BLOCK_BINDING          = 0x8A3F,
       |    GL_UNIFORM_BLOCK_DATA_SIZE        = 0x8A40,
       |    GL_UNIFORM_BLOCK_NAME_LENGTH      = 0x8A41,
       |    GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS  = 0x8A42,
       |    GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8A43,
       |    GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8A44,
       |    GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER = 0x8A45,
       |    GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8A46,
       |    GL_INVALID_INDEX                  = 0xFFFFFFFFu,
       |
       |    // ARB_copy_buffer
       |    GL_COPY_READ_BUFFER               = 0x8F36,
       |    GL_COPY_WRITE_BUFFER              = 0x8F37,
       |
       |    // ARB_depth_clamp
       |    GL_DEPTH_CLAMP                    = 0x864F,
       |
       |    // ARB_provoking_vertex
       |    GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION = 0x8E4C,
       |    GL_FIRST_VERTEX_CONVENTION        = 0x8E4D,
       |    GL_LAST_VERTEX_CONVENTION         = 0x8E4E,
       |    GL_PROVOKING_VERTEX               = 0x8E4F,
       |
       |    // ARB_seamless_cube_map
       |    GL_TEXTURE_CUBE_MAP_SEAMLESS      = 0x884F,
       |
       |    // ARB_sync
       |    GL_MAX_SERVER_WAIT_TIMEOUT        = 0x9111,
       |    GL_OBJECT_TYPE                    = 0x9112,
       |    GL_SYNC_CONDITION                 = 0x9113,
       |    GL_SYNC_STATUS                    = 0x9114,
       |    GL_SYNC_FLAGS                     = 0x9115,
       |    GL_SYNC_FENCE                     = 0x9116,
       |    GL_SYNC_GPU_COMMANDS_COMPLETE     = 0x9117,
       |    GL_UNSIGNALED                     = 0x9118,
       |    GL_SIGNALED                       = 0x9119,
       |    GL_ALREADY_SIGNALED               = 0x911A,
       |    GL_TIMEOUT_EXPIRED                = 0x911B,
       |    GL_CONDITION_SATISFIED            = 0x911C,
       |    GL_WAIT_FAILED                    = 0x911D,
       |    GL_SYNC_FLUSH_COMMANDS_BIT        = 0x00000001,
       |
       |    // ARB_texture_multisample
       |    GL_SAMPLE_POSITION                = 0x8E50,
       |    GL_SAMPLE_MASK                    = 0x8E51,
       |    GL_SAMPLE_MASK_VALUE              = 0x8E52,
       |    GL_MAX_SAMPLE_MASK_WORDS          = 0x8E59,
       |    GL_TEXTURE_2D_MULTISAMPLE         = 0x9100,
       |    GL_PROXY_TEXTURE_2D_MULTISAMPLE   = 0x9101,
       |    GL_TEXTURE_2D_MULTISAMPLE_ARRAY   = 0x9102,
       |    GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY = 0x9103,
       |    GL_TEXTURE_BINDING_2D_MULTISAMPLE = 0x9104,
       |    GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY = 0x9105,
       |    GL_TEXTURE_SAMPLES                = 0x9106,
       |    GL_TEXTURE_FIXED_SAMPLE_LOCATIONS = 0x9107,
       |    GL_SAMPLER_2D_MULTISAMPLE         = 0x9108,
       |    GL_INT_SAMPLER_2D_MULTISAMPLE     = 0x9109,
       |    GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE = 0x910A,
       |    GL_SAMPLER_2D_MULTISAMPLE_ARRAY   = 0x910B,
       |    GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910C,
       |    GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY = 0x910D,
       |    GL_MAX_COLOR_TEXTURE_SAMPLES      = 0x910E,
       |    GL_MAX_DEPTH_TEXTURE_SAMPLES      = 0x910F,
       |    GL_MAX_INTEGER_SAMPLES            = 0x9110,
       |
       |    // ARB_sample_shading
       |    GL_SAMPLE_SHADING_ARB             = 0x8C36,
       |    GL_MIN_SAMPLE_SHADING_VALUE_ARB   = 0x8C37,
       |
       |    // ARB_texture_cube_map_array
       |    GL_TEXTURE_CUBE_MAP_ARRAY_ARB     = 0x9009,
       |    GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB = 0x900A,
       |    GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB = 0x900B,
       |    GL_SAMPLER_CUBE_MAP_ARRAY_ARB     = 0x900C,
       |    GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB = 0x900D,
       |    GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900E,
       |    GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900F,
       |
       |    // ARB_texture_gather
       |    GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = 0x8E5E,
       |    GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = 0x8E5F,
       |
       |    // ARB_shading_language_include
       |    GL_SHADER_INCLUDE_ARB             = 0x8DAE,
       |    GL_NAMED_STRING_LENGTH_ARB        = 0x8DE9,
       |    GL_NAMED_STRING_TYPE_ARB          = 0x8DEA,
       |
       |    // ARB_texture_compression_bptc
       |    GL_COMPRESSED_RGBA_BPTC_UNORM_ARB = 0x8E8C,
       |    GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB = 0x8E8D,
       |    GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB = 0x8E8E,
       |    GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB = 0x8E8F,
       |
       |    // ARB_blend_func_extended
       |    GL_SRC1_COLOR                     = 0x88F9,
       |    GL_ONE_MINUS_SRC1_COLOR           = 0x88FA,
       |    GL_ONE_MINUS_SRC1_ALPHA           = 0x88FB,
       |    GL_MAX_DUAL_SOURCE_DRAW_BUFFERS   = 0x88FC,
       |
       |    // ARB_occlusion_query2
       |    GL_ANY_SAMPLES_PASSED             = 0x8C2F,
       |
       |    // ARB_sampler_objects
       |    GL_SAMPLER_BINDING                = 0x8919,
       |
       |    // ARB_texture_rgb10_a2ui
       |    GL_RGB10_A2UI                     = 0x906F,
       |
       |    // ARB_texture_swizzle
       |    GL_TEXTURE_SWIZZLE_R              = 0x8E42,
       |    GL_TEXTURE_SWIZZLE_G              = 0x8E43,
       |    GL_TEXTURE_SWIZZLE_B              = 0x8E44,
       |    GL_TEXTURE_SWIZZLE_A              = 0x8E45,
       |    GL_TEXTURE_SWIZZLE_RGBA           = 0x8E46,
       |
       |    // ARB_timer_query
       |    GL_TIME_ELAPSED                   = 0x88BF,
       |    GL_TIMESTAMP                      = 0x8E28,
       |
       |    // ARB_vertex_type_2_10_10_10_rev
       |    GL_INT_2_10_10_10_REV             = 0x8D9F,
       |
       |    // ARB_draw_indirect
       |    GL_DRAW_INDIRECT_BUFFER           = 0x8F3F,
       |    GL_DRAW_INDIRECT_BUFFER_BINDING   = 0x8F43,
       |
       |    // ARB_gpu_shader5
       |    GL_GEOMETRY_SHADER_INVOCATIONS    = 0x887F,
       |    GL_MAX_GEOMETRY_SHADER_INVOCATIONS = 0x8E5A,
       |    GL_MIN_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5B,
       |    GL_MAX_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5C,
       |    GL_FRAGMENT_INTERPOLATION_OFFSET_BITS = 0x8E5D,
       |
       |    // ARB_gpu_shader_fp64
       |    GL_DOUBLE_VEC2                    = 0x8FFC,
       |    GL_DOUBLE_VEC3                    = 0x8FFD,
       |    GL_DOUBLE_VEC4                    = 0x8FFE,
       |    GL_DOUBLE_MAT2                    = 0x8F46,
       |    GL_DOUBLE_MAT3                    = 0x8F47,
       |    GL_DOUBLE_MAT4                    = 0x8F48,
       |    GL_DOUBLE_MAT2x3                  = 0x8F49,
       |    GL_DOUBLE_MAT2x4                  = 0x8F4A,
       |    GL_DOUBLE_MAT3x2                  = 0x8F4B,
       |    GL_DOUBLE_MAT3x4                  = 0x8F4C,
       |    GL_DOUBLE_MAT4x2                  = 0x8F4D,
       |    GL_DOUBLE_MAT4x3                  = 0x8F4E,
       |
       |    // ARB_shader_subroutine
       |    GL_ACTIVE_SUBROUTINES             = 0x8DE5,
       |    GL_ACTIVE_SUBROUTINE_UNIFORMS     = 0x8DE6,
       |    GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS = 0x8E47,
       |    GL_ACTIVE_SUBROUTINE_MAX_LENGTH   = 0x8E48,
       |    GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH = 0x8E49,
       |    GL_MAX_SUBROUTINES                = 0x8DE7,
       |    GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS = 0x8DE8,
       |    GL_NUM_COMPATIBLE_SUBROUTINES     = 0x8E4A,
       |    GL_COMPATIBLE_SUBROUTINES         = 0x8E4B,
       |
       |    // ARB_tessellation_shader
       |    GL_PATCHES                        = 0x000E,
       |    GL_PATCH_VERTICES                 = 0x8E72,
       |    GL_PATCH_DEFAULT_INNER_LEVEL      = 0x8E73,
       |    GL_PATCH_DEFAULT_OUTER_LEVEL      = 0x8E74,
       |    GL_TESS_CONTROL_OUTPUT_VERTICES   = 0x8E75,
       |    GL_TESS_GEN_MODE                  = 0x8E76,
       |    GL_TESS_GEN_SPACING               = 0x8E77,
       |    GL_TESS_GEN_VERTEX_ORDER          = 0x8E78,
       |    GL_TESS_GEN_POINT_MODE            = 0x8E79,
       |    GL_ISOLINES                       = 0x8E7A,
       |    GL_FRACTIONAL_ODD                 = 0x8E7B,
       |    GL_FRACTIONAL_EVEN                = 0x8E7C,
       |    GL_MAX_PATCH_VERTICES             = 0x8E7D,
       |    GL_MAX_TESS_GEN_LEVEL             = 0x8E7E,
       |    GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E7F,
       |    GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E80,
       |    GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS = 0x8E81,
       |    GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS = 0x8E82,
       |    GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS = 0x8E83,
       |    GL_MAX_TESS_PATCH_COMPONENTS      = 0x8E84,
       |    GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS = 0x8E85,
       |    GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS = 0x8E86,
       |    GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS = 0x8E89,
       |    GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS = 0x8E8A,
       |    GL_MAX_TESS_CONTROL_INPUT_COMPONENTS = 0x886C,
       |    GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS = 0x886D,
       |    GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS = 0x8E1E,
       |    GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS = 0x8E1F,
       |    GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER = 0x84F0,
       |    GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x84F1,
       |    GL_TESS_EVALUATION_SHADER         = 0x8E87,
       |    GL_TESS_CONTROL_SHADER            = 0x8E88,
       |
       |    // ARB_transform_feedback2
       |    GL_TRANSFORM_FEEDBACK             = 0x8E22,
       |    GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED = 0x8E23,
       |    GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE = 0x8E24,
       |    GL_TRANSFORM_FEEDBACK_BINDING     = 0x8E25,
       |
       |    // ARB_transform_feedback3
       |    GL_MAX_TRANSFORM_FEEDBACK_BUFFERS = 0x8E70,
       |    GL_MAX_VERTEX_STREAMS             = 0x8E71,
       |
       |    // ARB_ES2_compatibility
       |    GL_FIXED                          = 0x140C,
       |    GL_IMPLEMENTATION_COLOR_READ_TYPE = 0x8B9A,
       |    GL_IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B,
       |    GL_LOW_FLOAT                      = 0x8DF0,
       |    GL_MEDIUM_FLOAT                   = 0x8DF1,
       |    GL_HIGH_FLOAT                     = 0x8DF2,
       |    GL_LOW_INT                        = 0x8DF3,
       |    GL_MEDIUM_INT                     = 0x8DF4,
       |    GL_HIGH_INT                       = 0x8DF5,
       |    GL_SHADER_COMPILER                = 0x8DFA,
       |    GL_NUM_SHADER_BINARY_FORMATS      = 0x8DF9,
       |    GL_MAX_VERTEX_UNIFORM_VECTORS     = 0x8DFB,
       |    GL_MAX_VARYING_VECTORS            = 0x8DFC,
       |    GL_MAX_FRAGMENT_UNIFORM_VECTORS   = 0x8DFD,
       |
       |    // ARB_get_program_binary
       |    GL_PROGRAM_BINARY_RETRIEVABLE_HINT = 0x8257,
       |    GL_PROGRAM_BINARY_LENGTH          = 0x8741,
       |    GL_NUM_PROGRAM_BINARY_FORMATS     = 0x87FE,
       |    GL_PROGRAM_BINARY_FORMATS         = 0x87FF,
       |
       |    // ARB_separate_shader_objects
       |    GL_VERTEX_SHADER_BIT              = 0x00000001,
       |    GL_FRAGMENT_SHADER_BIT            = 0x00000002,
       |    GL_GEOMETRY_SHADER_BIT            = 0x00000004,
       |    GL_TESS_CONTROL_SHADER_BIT        = 0x00000008,
       |    GL_TESS_EVALUATION_SHADER_BIT     = 0x00000010,
       |    GL_ALL_SHADER_BITS                = 0xFFFFFFFF,
       |    GL_PROGRAM_SEPARABLE              = 0x8258,
       |    GL_ACTIVE_PROGRAM                 = 0x8259,
       |    GL_PROGRAM_PIPELINE_BINDING       = 0x825A,
       |
       |    // ARB_viewport_array
       |    GL_MAX_VIEWPORTS                  = 0x825B,
       |    GL_VIEWPORT_SUBPIXEL_BITS         = 0x825C,
       |    GL_VIEWPORT_BOUNDS_RANGE          = 0x825D,
       |    GL_LAYER_PROVOKING_VERTEX         = 0x825E,
       |    GL_VIEWPORT_INDEX_PROVOKING_VERTEX = 0x825F,
       |    GL_UNDEFINED_VERTEX               = 0x8260,
       |
       |    // ARB_cl_event
       |    GL_SYNC_CL_EVENT_ARB              = 0x8240,
       |    GL_SYNC_CL_EVENT_COMPLETE_ARB     = 0x8241,
       |
       |    // ARB_debug_output
       |    GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB   = 0x8242,
       |    GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB = 0x8243,
       |    GL_DEBUG_CALLBACK_FUNCTION_ARB    = 0x8244,
       |    GL_DEBUG_CALLBACK_USER_PARAM_ARB  = 0x8245,
       |    GL_DEBUG_SOURCE_API_ARB           = 0x8246,
       |    GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB = 0x8247,
       |    GL_DEBUG_SOURCE_SHADER_COMPILER_ARB = 0x8248,
       |    GL_DEBUG_SOURCE_THIRD_PARTY_ARB   = 0x8249,
       |    GL_DEBUG_SOURCE_APPLICATION_ARB   = 0x824A,
       |    GL_DEBUG_SOURCE_OTHER_ARB         = 0x824B,
       |    GL_DEBUG_TYPE_ERROR_ARB           = 0x824C,
       |    GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB = 0x824D,
       |    GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB = 0x824E,
       |    GL_DEBUG_TYPE_PORTABILITY_ARB     = 0x824F,
       |    GL_DEBUG_TYPE_PERFORMANCE_ARB     = 0x8250,
       |    GL_DEBUG_TYPE_OTHER_ARB           = 0x8251,
       |    GL_MAX_DEBUG_MESSAGE_LENGTH_ARB   = 0x9143,
       |    GL_MAX_DEBUG_LOGGED_MESSAGES_ARB  = 0x9144,
       |    GL_DEBUG_LOGGED_MESSAGES_ARB      = 0x9145,
       |    GL_DEBUG_SEVERITY_HIGH_ARB        = 0x9146,
       |    GL_DEBUG_SEVERITY_MEDIUM_ARB      = 0x9147,
       |    GL_DEBUG_SEVERITY_LOW_ARB         = 0x9148,
       |
       |    // ARB_robustness
       |    GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB = 0x00000004,
       |    GL_LOSE_CONTEXT_ON_RESET_ARB      = 0x8252,
       |    GL_GUILTY_CONTEXT_RESET_ARB       = 0x8253,
       |    GL_INNOCENT_CONTEXT_RESET_ARB     = 0x8254,
       |    GL_UNKNOWN_CONTEXT_RESET_ARB      = 0x8255,
       |    GL_RESET_NOTIFICATION_STRATEGY_ARB = 0x8256,
       |    GL_NO_RESET_NOTIFICATION_ARB      = 0x8261,
       |
       |    // ARB_compressed_texture_pixel_storage
       |    GL_UNPACK_COMPRESSED_BLOCK_WIDTH  = 0x9127,
       |    GL_UNPACK_COMPRESSED_BLOCK_HEIGHT = 0x9128,
       |    GL_UNPACK_COMPRESSED_BLOCK_DEPTH  = 0x9129,
       |    GL_UNPACK_COMPRESSED_BLOCK_SIZE   = 0x912A,
       |    GL_PACK_COMPRESSED_BLOCK_WIDTH    = 0x912B,
       |    GL_PACK_COMPRESSED_BLOCK_HEIGHT   = 0x912C,
       |    GL_PACK_COMPRESSED_BLOCK_DEPTH    = 0x912D,
       |    GL_PACK_COMPRESSED_BLOCK_SIZE     = 0x912E,
       |
       |    // ARB_internalformat_query
       |    GL_NUM_SAMPLE_COUNTS              = 0x9380,
       |
       |    // ARB_map_buffer_alignment
       |    GL_MIN_MAP_BUFFER_ALIGNMENT       = 0x90BC,
       |
       |    // ARB_shader_atomic_counters
       |    GL_ATOMIC_COUNTER_BUFFER          = 0x92C0,
       |    GL_ATOMIC_COUNTER_BUFFER_BINDING  = 0x92C1,
       |    GL_ATOMIC_COUNTER_BUFFER_START    = 0x92C2,
       |    GL_ATOMIC_COUNTER_BUFFER_SIZE     = 0x92C3,
       |    GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE = 0x92C4,
       |    GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS = 0x92C5,
       |    GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES = 0x92C6,
       |    GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER = 0x92C7,
       |    GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER = 0x92C8,
       |    GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x92C9,
       |    GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER = 0x92CA,
       |    GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER = 0x92CB,
       |    GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = 0x92CC,
       |    GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS = 0x92CD,
       |    GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS = 0x92CE,
       |    GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS = 0x92CF,
       |    GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS = 0x92D0,
       |    GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS = 0x92D1,
       |    GL_MAX_VERTEX_ATOMIC_COUNTERS     = 0x92D2,
       |    GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS = 0x92D3,
       |    GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS = 0x92D4,
       |    GL_MAX_GEOMETRY_ATOMIC_COUNTERS   = 0x92D5,
       |    GL_MAX_FRAGMENT_ATOMIC_COUNTERS   = 0x92D6,
       |    GL_MAX_COMBINED_ATOMIC_COUNTERS   = 0x92D7,
       |    GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE = 0x92D8,
       |    GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS = 0x92DC,
       |    GL_ACTIVE_ATOMIC_COUNTER_BUFFERS  = 0x92D9,
       |    GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX = 0x92DA,
       |    GL_UNSIGNED_INT_ATOMIC_COUNTER    = 0x92DB,
       |
       |    // ARB_shader_image_load_store
       |    GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT = 0x00000001,
       |    GL_ELEMENT_ARRAY_BARRIER_BIT      = 0x00000002,
       |    GL_UNIFORM_BARRIER_BIT            = 0x00000004,
       |    GL_TEXTURE_FETCH_BARRIER_BIT      = 0x00000008,
       |    GL_SHADER_IMAGE_ACCESS_BARRIER_BIT = 0x00000020,
       |    GL_COMMAND_BARRIER_BIT            = 0x00000040,
       |    GL_PIXEL_BUFFER_BARRIER_BIT       = 0x00000080,
       |    GL_TEXTURE_UPDATE_BARRIER_BIT     = 0x00000100,
       |    GL_BUFFER_UPDATE_BARRIER_BIT      = 0x00000200,
       |    GL_FRAMEBUFFER_BARRIER_BIT        = 0x00000400,
       |    GL_TRANSFORM_FEEDBACK_BARRIER_BIT = 0x00000800,
       |    GL_ATOMIC_COUNTER_BARRIER_BIT     = 0x00001000,
       |    GL_ALL_BARRIER_BITS               = 0xFFFFFFFF,
       |    GL_MAX_IMAGE_UNITS                = 0x8F38,
       |    GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS = 0x8F39,
       |    GL_IMAGE_BINDING_NAME             = 0x8F3A,
       |    GL_IMAGE_BINDING_LEVEL            = 0x8F3B,
       |    GL_IMAGE_BINDING_LAYERED          = 0x8F3C,
       |    GL_IMAGE_BINDING_LAYER            = 0x8F3D,
       |    GL_IMAGE_BINDING_ACCESS           = 0x8F3E,
       |    GL_IMAGE_1D                       = 0x904C,
       |    GL_IMAGE_2D                       = 0x904D,
       |    GL_IMAGE_3D                       = 0x904E,
       |    GL_IMAGE_2D_RECT                  = 0x904F,
       |    GL_IMAGE_CUBE                     = 0x9050,
       |    GL_IMAGE_BUFFER                   = 0x9051,
       |    GL_IMAGE_1D_ARRAY                 = 0x9052,
       |    GL_IMAGE_2D_ARRAY                 = 0x9053,
       |    GL_IMAGE_CUBE_MAP_ARRAY           = 0x9054,
       |    GL_IMAGE_2D_MULTISAMPLE           = 0x9055,
       |    GL_IMAGE_2D_MULTISAMPLE_ARRAY     = 0x9056,
       |    GL_INT_IMAGE_1D                   = 0x9057,
       |    GL_INT_IMAGE_2D                   = 0x9058,
       |    GL_INT_IMAGE_3D                   = 0x9059,
       |    GL_INT_IMAGE_2D_RECT              = 0x905A,
       |    GL_INT_IMAGE_CUBE                 = 0x905B,
       |    GL_INT_IMAGE_BUFFER               = 0x905C,
       |    GL_INT_IMAGE_1D_ARRAY             = 0x905D,
       |    GL_INT_IMAGE_2D_ARRAY             = 0x905E,
       |    GL_INT_IMAGE_CUBE_MAP_ARRAY       = 0x905F,
       |    GL_INT_IMAGE_2D_MULTISAMPLE       = 0x9060,
       |    GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x9061,
       |    GL_UNSIGNED_INT_IMAGE_1D          = 0x9062,
       |    GL_UNSIGNED_INT_IMAGE_2D          = 0x9063,
       |    GL_UNSIGNED_INT_IMAGE_3D          = 0x9064,
       |    GL_UNSIGNED_INT_IMAGE_2D_RECT     = 0x9065,
       |    GL_UNSIGNED_INT_IMAGE_CUBE        = 0x9066,
       |    GL_UNSIGNED_INT_IMAGE_BUFFER      = 0x9067,
       |    GL_UNSIGNED_INT_IMAGE_1D_ARRAY    = 0x9068,
       |    GL_UNSIGNED_INT_IMAGE_2D_ARRAY    = 0x9069,
       |    GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY = 0x906A,
       |    GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE = 0x906B,
       |    GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x906C,
       |    GL_MAX_IMAGE_SAMPLES              = 0x906D,
       |    GL_IMAGE_BINDING_FORMAT           = 0x906E,
       |    GL_IMAGE_FORMAT_COMPATIBILITY_TYPE = 0x90C7,
       |    GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE = 0x90C8,
       |    GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS = 0x90C9,
       |    GL_MAX_VERTEX_IMAGE_UNIFORMS      = 0x90CA,
       |    GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS = 0x90CB,
       |    GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS = 0x90CC,
       |    GL_MAX_GEOMETRY_IMAGE_UNIFORMS    = 0x90CD,
       |    GL_MAX_FRAGMENT_IMAGE_UNIFORMS    = 0x90CE,
       |    GL_MAX_COMBINED_IMAGE_UNIFORMS    = 0x90CF,
       |
       |    // ARB_texture_storage
       |    GL_TEXTURE_IMMUTABLE_FORMAT       = 0x912F,
       |
       |    // ARB_ES3_compatibility
       |    GL_COMPRESSED_RGB8_ETC2           = 0x9274,
       |    GL_COMPRESSED_SRGB8_ETC2          = 0x9275,
       |    GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9276,
       |    GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277,
       |    GL_COMPRESSED_RGBA8_ETC2_EAC      = 0x9278,
       |    GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 0x9279,
       |    GL_COMPRESSED_R11_EAC             = 0x9270,
       |    GL_COMPRESSED_SIGNED_R11_EAC      = 0x9271,
       |    GL_COMPRESSED_RG11_EAC            = 0x9272,
       |    GL_COMPRESSED_SIGNED_RG11_EAC     = 0x9273,
       |    GL_PRIMITIVE_RESTART_FIXED_INDEX  = 0x8D69,
       |    GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A,
       |    GL_MAX_ELEMENT_INDEX              = 0x8D6B,
       |
       |    // ARB_compute_shader
       |    GL_COMPUTE_SHADER                 = 0x91B9,
       |    GL_MAX_COMPUTE_UNIFORM_BLOCKS     = 0x91BB,
       |    GL_MAX_COMPUTE_TEXTURE_IMAGE_UNITS = 0x91BC,
       |    GL_MAX_COMPUTE_IMAGE_UNIFORMS     = 0x91BD,
       |    GL_MAX_COMPUTE_SHARED_MEMORY_SIZE = 0x8262,
       |    GL_MAX_COMPUTE_UNIFORM_COMPONENTS = 0x8263,
       |    GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS = 0x8264,
       |    GL_MAX_COMPUTE_ATOMIC_COUNTERS    = 0x8265,
       |    GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS = 0x8266,
       |    GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS  = 0x90EB,
       |    GL_MAX_COMPUTE_WORK_GROUP_COUNT   = 0x91BE,
       |    GL_MAX_COMPUTE_WORK_GROUP_SIZE    = 0x91BF,
       |    GL_COMPUTE_WORK_GROUP_SIZE        = 0x8267,
       |    GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER = 0x90EC,
       |    GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER = 0x90ED,
       |    GL_DISPATCH_INDIRECT_BUFFER       = 0x90EE,
       |    GL_DISPATCH_INDIRECT_BUFFER_BINDING = 0x90EF,
       |    GL_COMPUTE_SHADER_BIT             = 0x00000020,
       |
       |    // KHR_debug
       |    GL_DEBUG_OUTPUT_SYNCHRONOUS       = 0x8242,
       |    GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH = 0x8243,
       |    GL_DEBUG_CALLBACK_FUNCTION        = 0x8244,
       |    GL_DEBUG_CALLBACK_USER_PARAM      = 0x8245,
       |    GL_DEBUG_SOURCE_API               = 0x8246,
       |    GL_DEBUG_SOURCE_WINDOW_SYSTEM     = 0x8247,
       |    GL_DEBUG_SOURCE_SHADER_COMPILER   = 0x8248,
       |    GL_DEBUG_SOURCE_THIRD_PARTY       = 0x8249,
       |    GL_DEBUG_SOURCE_APPLICATION       = 0x824A,
       |    GL_DEBUG_SOURCE_OTHER             = 0x824B,
       |    GL_DEBUG_TYPE_ERROR               = 0x824C,
       |    GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR = 0x824D,
       |    GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR  = 0x824E,
       |    GL_DEBUG_TYPE_PORTABILITY         = 0x824F,
       |    GL_DEBUG_TYPE_PERFORMANCE         = 0x8250,
       |    GL_DEBUG_TYPE_OTHER               = 0x8251,
       |    GL_DEBUG_TYPE_MARKER              = 0x8268,
       |    GL_DEBUG_TYPE_PUSH_GROUP          = 0x8269,
       |    GL_DEBUG_TYPE_POP_GROUP           = 0x826A,
       |    GL_DEBUG_SEVERITY_NOTIFICATION    = 0x826B,
       |    GL_MAX_DEBUG_GROUP_STACK_DEPTH    = 0x826C,
       |    GL_DEBUG_GROUP_STACK_DEPTH        = 0x826D,
       |    GL_BUFFER                         = 0x82E0,
       |    GL_SHADER                         = 0x82E1,
       |    GL_PROGRAM                        = 0x82E2,
       |    GL_QUERY                          = 0x82E3,
       |    GL_PROGRAM_PIPELINE               = 0x82E4,
       |    GL_SAMPLER                        = 0x82E6,
       |    GL_DISPLAY_LIST                   = 0x82E7,
       |    GL_MAX_LABEL_LENGTH               = 0x82E8,
       |    GL_MAX_DEBUG_MESSAGE_LENGTH       = 0x9143,
       |    GL_MAX_DEBUG_LOGGED_MESSAGES      = 0x9144,
       |    GL_DEBUG_LOGGED_MESSAGES          = 0x9145,
       |    GL_DEBUG_SEVERITY_HIGH            = 0x9146,
       |    GL_DEBUG_SEVERITY_MEDIUM          = 0x9147,
       |    GL_DEBUG_SEVERITY_LOW             = 0x9148,
       |    GL_DEBUG_OUTPUT                   = 0x92E0,
       |    GL_CONTEXT_FLAG_DEBUG_BIT         = 0x00000002,
       |
       |    // ARB_explicit_uniform_location
       |    GL_MAX_UNIFORM_LOCATIONS = 0x826E,
       |
       |    // ARB_framebuffer_no_attachments
       |    GL_FRAMEBUFFER_DEFAULT_WIDTH      = 0x9310,
       |    GL_FRAMEBUFFER_DEFAULT_HEIGHT     = 0x9311,
       |    GL_FRAMEBUFFER_DEFAULT_LAYERS     = 0x9312,
       |    GL_FRAMEBUFFER_DEFAULT_SAMPLES    = 0x9313,
       |    GL_FRAMEBUFFER_DEFAULT_FIXED_SAMPLE_LOCATIONS = 0x9314,
       |    GL_MAX_FRAMEBUFFER_WIDTH          = 0x9315,
       |    GL_MAX_FRAMEBUFFER_HEIGHT         = 0x9316,
       |    GL_MAX_FRAMEBUFFER_LAYERS         = 0x9317,
       |    GL_MAX_FRAMEBUFFER_SAMPLES        = 0x9318,
       |
       |    // ARB_internalformat_query2
       |    GL_INTERNALFORMAT_SUPPORTED       = 0x826F,
       |    GL_INTERNALFORMAT_PREFERRED       = 0x8270,
       |    GL_INTERNALFORMAT_RED_SIZE        = 0x8271,
       |    GL_INTERNALFORMAT_GREEN_SIZE      = 0x8272,
       |    GL_INTERNALFORMAT_BLUE_SIZE       = 0x8273,
       |    GL_INTERNALFORMAT_ALPHA_SIZE      = 0x8274,
       |    GL_INTERNALFORMAT_DEPTH_SIZE      = 0x8275,
       |    GL_INTERNALFORMAT_STENCIL_SIZE    = 0x8276,
       |    GL_INTERNALFORMAT_SHARED_SIZE     = 0x8277,
       |    GL_INTERNALFORMAT_RED_TYPE        = 0x8278,
       |    GL_INTERNALFORMAT_GREEN_TYPE      = 0x8279,
       |    GL_INTERNALFORMAT_BLUE_TYPE       = 0x827A,
       |    GL_INTERNALFORMAT_ALPHA_TYPE      = 0x827B,
       |    GL_INTERNALFORMAT_DEPTH_TYPE      = 0x827C,
       |    GL_INTERNALFORMAT_STENCIL_TYPE    = 0x827D,
       |    GL_MAX_WIDTH                      = 0x827E,
       |    GL_MAX_HEIGHT                     = 0x827F,
       |    GL_MAX_DEPTH                      = 0x8280,
       |    GL_MAX_LAYERS                     = 0x8281,
       |    GL_MAX_COMBINED_DIMENSIONS        = 0x8282,
       |    GL_COLOR_COMPONENTS               = 0x8283,
       |    GL_DEPTH_COMPONENTS               = 0x8284,
       |    GL_STENCIL_COMPONENTS             = 0x8285,
       |    GL_COLOR_RENDERABLE               = 0x8286,
       |    GL_DEPTH_RENDERABLE               = 0x8287,
       |    GL_STENCIL_RENDERABLE             = 0x8288,
       |    GL_FRAMEBUFFER_RENDERABLE         = 0x8289,
       |    GL_FRAMEBUFFER_RENDERABLE_LAYERED = 0x828A,
       |    GL_FRAMEBUFFER_BLEND              = 0x828B,
       |    GL_READ_PIXELS                    = 0x828C,
       |    GL_READ_PIXELS_FORMAT             = 0x828D,
       |    GL_READ_PIXELS_TYPE               = 0x828E,
       |    GL_TEXTURE_IMAGE_FORMAT           = 0x828F,
       |    GL_TEXTURE_IMAGE_TYPE             = 0x8290,
       |    GL_GET_TEXTURE_IMAGE_FORMAT       = 0x8291,
       |    GL_GET_TEXTURE_IMAGE_TYPE         = 0x8292,
       |    GL_MIPMAP                         = 0x8293,
       |    GL_MANUAL_GENERATE_MIPMAP         = 0x8294,
       |    GL_AUTO_GENERATE_MIPMAP           = 0x8295,
       |    GL_COLOR_ENCODING                 = 0x8296,
       |    GL_SRGB_READ                      = 0x8297,
       |    GL_SRGB_WRITE                     = 0x8298,
       |    GL_SRGB_DECODE_ARB                = 0x8299,
       |    GL_FILTER                         = 0x829A,
       |    GL_VERTEX_TEXTURE                 = 0x829B,
       |    GL_TESS_CONTROL_TEXTURE           = 0x829C,
       |    GL_TESS_EVALUATION_TEXTURE        = 0x829D,
       |    GL_GEOMETRY_TEXTURE               = 0x829E,
       |    GL_FRAGMENT_TEXTURE               = 0x829F,
       |    GL_COMPUTE_TEXTURE                = 0x82A0,
       |    GL_TEXTURE_SHADOW                 = 0x82A1,
       |    GL_TEXTURE_GATHER                 = 0x82A2,
       |    GL_TEXTURE_GATHER_SHADOW          = 0x82A3,
       |    GL_SHADER_IMAGE_LOAD              = 0x82A4,
       |    GL_SHADER_IMAGE_STORE             = 0x82A5,
       |    GL_SHADER_IMAGE_ATOMIC            = 0x82A6,
       |    GL_IMAGE_TEXEL_SIZE               = 0x82A7,
       |    GL_IMAGE_COMPATIBILITY_CLASS      = 0x82A8,
       |    GL_IMAGE_PIXEL_FORMAT             = 0x82A9,
       |    GL_IMAGE_PIXEL_TYPE               = 0x82AA,
       |    GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST = 0x82AC,
       |    GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST = 0x82AD,
       |    GL_SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE = 0x82AE,
       |    GL_SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE = 0x82AF,
       |    GL_TEXTURE_COMPRESSED_BLOCK_WIDTH = 0x82B1,
       |    GL_TEXTURE_COMPRESSED_BLOCK_HEIGHT = 0x82B2,
       |    GL_TEXTURE_COMPRESSED_BLOCK_SIZE  = 0x82B3,
       |    GL_CLEAR_BUFFER                   = 0x82B4,
       |    GL_TEXTURE_VIEW                   = 0x82B5,
       |    GL_VIEW_COMPATIBILITY_CLASS       = 0x82B6,
       |    GL_FULL_SUPPORT                   = 0x82B7,
       |    GL_CAVEAT_SUPPORT                 = 0x82B8,
       |    GL_IMAGE_CLASS_4_X_32             = 0x82B9,
       |    GL_IMAGE_CLASS_2_X_32             = 0x82BA,
       |    GL_IMAGE_CLASS_1_X_32             = 0x82BB,
       |    GL_IMAGE_CLASS_4_X_16             = 0x82BC,
       |    GL_IMAGE_CLASS_2_X_16             = 0x82BD,
       |    GL_IMAGE_CLASS_1_X_16             = 0x82BE,
       |    GL_IMAGE_CLASS_4_X_8              = 0x82BF,
       |    GL_IMAGE_CLASS_2_X_8              = 0x82C0,
       |    GL_IMAGE_CLASS_1_X_8              = 0x82C1,
       |    GL_IMAGE_CLASS_11_11_10           = 0x82C2,
       |    GL_IMAGE_CLASS_10_10_10_2         = 0x82C3,
       |    GL_VIEW_CLASS_128_BITS            = 0x82C4,
       |    GL_VIEW_CLASS_96_BITS             = 0x82C5,
       |    GL_VIEW_CLASS_64_BITS             = 0x82C6,
       |    GL_VIEW_CLASS_48_BITS             = 0x82C7,
       |    GL_VIEW_CLASS_32_BITS             = 0x82C8,
       |    GL_VIEW_CLASS_24_BITS             = 0x82C9,
       |    GL_VIEW_CLASS_16_BITS             = 0x82CA,
       |    GL_VIEW_CLASS_8_BITS              = 0x82CB,
       |    GL_VIEW_CLASS_S3TC_DXT1_RGB       = 0x82CC,
       |    GL_VIEW_CLASS_S3TC_DXT1_RGBA      = 0x82CD,
       |    GL_VIEW_CLASS_S3TC_DXT3_RGBA      = 0x82CE,
       |    GL_VIEW_CLASS_S3TC_DXT5_RGBA      = 0x82CF,
       |    GL_VIEW_CLASS_RGTC1_RED           = 0x82D0,
       |    GL_VIEW_CLASS_RGTC2_RG            = 0x82D1,
       |    GL_VIEW_CLASS_BPTC_UNORM          = 0x82D2,
       |    GL_VIEW_CLASS_BPTC_FLOAT          = 0x82D3,
       |
       |    // ARB_program_interface_query
       |    GL_UNIFORM                        = 0x92E1,
       |    GL_UNIFORM_BLOCK                  = 0x92E2,
       |    GL_PROGRAM_INPUT                  = 0x92E3,
       |    GL_PROGRAM_OUTPUT                 = 0x92E4,
       |    GL_BUFFER_VARIABLE                = 0x92E5,
       |    GL_SHADER_STORAGE_BLOCK           = 0x92E6,
       |    GL_VERTEX_SUBROUTINE              = 0x92E8,
       |    GL_TESS_CONTROL_SUBROUTINE        = 0x92E9,
       |    GL_TESS_EVALUATION_SUBROUTINE     = 0x92EA,
       |    GL_GEOMETRY_SUBROUTINE            = 0x92EB,
       |    GL_FRAGMENT_SUBROUTINE            = 0x92EC,
       |    GL_COMPUTE_SUBROUTINE             = 0x92ED,
       |    GL_VERTEX_SUBROUTINE_UNIFORM      = 0x92EE,
       |    GL_TESS_CONTROL_SUBROUTINE_UNIFORM = 0x92EF,
       |    GL_TESS_EVALUATION_SUBROUTINE_UNIFORM = 0x92F0,
       |    GL_GEOMETRY_SUBROUTINE_UNIFORM    = 0x92F1,
       |    GL_FRAGMENT_SUBROUTINE_UNIFORM    = 0x92F2,
       |    GL_COMPUTE_SUBROUTINE_UNIFORM     = 0x92F3,
       |    GL_TRANSFORM_FEEDBACK_VARYING     = 0x92F4,
       |    GL_ACTIVE_RESOURCES               = 0x92F5,
       |    GL_MAX_NAME_LENGTH                = 0x92F6,
       |    GL_MAX_NUM_ACTIVE_VARIABLES       = 0x92F7,
       |    GL_MAX_NUM_COMPATIBLE_SUBROUTINES = 0x92F8,
       |    GL_NAME_LENGTH                    = 0x92F9,
       |    GL_TYPE                           = 0x92FA,
       |    GL_ARRAY_SIZE                     = 0x92FB,
       |    GL_OFFSET                         = 0x92FC,
       |    GL_BLOCK_INDEX                    = 0x92FD,
       |    GL_ARRAY_STRIDE                   = 0x92FE,
       |    GL_MATRIX_STRIDE                  = 0x92FF,
       |    GL_IS_ROW_MAJOR                   = 0x9300,
       |    GL_ATOMIC_COUNTER_BUFFER_INDEX    = 0x9301,
       |    GL_BUFFER_BINDING                 = 0x9302,
       |    GL_BUFFER_DATA_SIZE               = 0x9303,
       |    GL_NUM_ACTIVE_VARIABLES           = 0x9304,
       |    GL_ACTIVE_VARIABLES               = 0x9305,
       |    GL_REFERENCED_BY_VERTEX_SHADER    = 0x9306,
       |    GL_REFERENCED_BY_TESS_CONTROL_SHADER = 0x9307,
       |    GL_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x9308,
       |    GL_REFERENCED_BY_GEOMETRY_SHADER  = 0x9309,
       |    GL_REFERENCED_BY_FRAGMENT_SHADER  = 0x930A,
       |    GL_REFERENCED_BY_COMPUTE_SHADER   = 0x930B,
       |    GL_TOP_LEVEL_ARRAY_SIZE           = 0x930C,
       |    GL_TOP_LEVEL_ARRAY_STRIDE         = 0x930D,
       |    GL_LOCATION                       = 0x930E,
       |    GL_LOCATION_INDEX                 = 0x930F,
       |    GL_IS_PER_PATCH                   = 0x92E7,
       |
       |    // ARB_shader_storage_buffer_object
       |    GL_SHADER_STORAGE_BUFFER          = 0x90D2,
       |    GL_SHADER_STORAGE_BUFFER_BINDING  = 0x90D3,
       |    GL_SHADER_STORAGE_BUFFER_START    = 0x90D4,
       |    GL_SHADER_STORAGE_BUFFER_SIZE     = 0x90D5,
       |    GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS = 0x90D6,
       |    GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS = 0x90D7,
       |    GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS = 0x90D8,
       |    GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS = 0x90D9,
       |    GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = 0x90DA,
       |    GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS = 0x90DB,
       |    GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS = 0x90DC,
       |    GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS = 0x90DD,
       |    GL_MAX_SHADER_STORAGE_BLOCK_SIZE  = 0x90DE,
       |    GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT = 0x90DF,
       |    GL_SHADER_STORAGE_BARRIER_BIT     = 0x2000,
       |    GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES = 0x8F39,
       |
       |    // ARB_stencil_texturing
       |    GL_DEPTH_STENCIL_TEXTURE_MODE = 0x90EA,
       |
       |    // ARB_texture_buffer_range
       |    GL_TEXTURE_BUFFER_OFFSET = 0x919D,
       |    GL_TEXTURE_BUFFER_SIZE = 0x919E,
       |    GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT = 0x919F,
       |
       |    // ARB_texture_view
       |    GL_TEXTURE_VIEW_MIN_LEVEL         = 0x82DB,
       |    GL_TEXTURE_VIEW_NUM_LEVELS        = 0x82DC,
       |    GL_TEXTURE_VIEW_MIN_LAYER         = 0x82DD,
       |    GL_TEXTURE_VIEW_NUM_LAYERS        = 0x82DE,
       |    GL_TEXTURE_IMMUTABLE_LEVELS       = 0x82DF,
       |
       |    // ARB_vertex_attrib_binding
       |    GL_VERTEX_ATTRIB_BINDING          = 0x82D4,
       |    GL_VERTEX_ATTRIB_RELATIVE_OFFSET  = 0x82D5,
       |    GL_VERTEX_BINDING_DIVISOR         = 0x82D6,
       |    GL_VERTEX_BINDING_OFFSET          = 0x82D7,
       |    GL_VERTEX_BINDING_STRIDE          = 0x82D8,
       |    GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET = 0x82D9,
       |    GL_MAX_VERTEX_ATTRIB_BINDINGS     = 0x82DA,
       |
       |    // ARB_buffer_storage
       |    GL_MAP_PERSISTENT_BIT             = 0x0040,
       |    GL_MAP_COHERENT_BIT               = 0x0080,
       |    GL_DYNAMIC_STORAGE_BIT            = 0x0100,
       |    GL_CLIENT_STORAGE_BIT             = 0x0200,
       |    GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT = 0x00004000,
       |    GL_BUFFER_IMMUTABLE_STORAGE       = 0x821F,
       |    GL_BUFFER_STORAGE_FLAGS           = 0x8220,
       |
       |    // ARB_clear_texture
       |    GL_CLEAR_TEXTURE = 0x9365,
       |
       |    // ARB_enhanced_layouts
       |    GL_LOCATION_COMPONENT             = 0x934A,
       |    GL_TRANSFORM_FEEDBACK_BUFFER_INDEX = 0x934B,
       |    GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE = 0x934C,
       |
       |    // ARB_query_buffer_object
       |    GL_QUERY_BUFFER                   = 0x9192,
       |    GL_QUERY_BUFFER_BARRIER_BIT       = 0x00008000,
       |    GL_QUERY_BUFFER_BINDING           = 0x9193,
       |    GL_QUERY_RESULT_NO_WAIT           = 0x9194,
       |
       |    // ARB_texture_mirror_clamp_to_edge
       |    GL_MIRROR_CLAMP_TO_EDGE           = 0x8743,
       |
       |    // ARB_clip_control
       |    GL_NEGATIVE_ONE_TO_ONE            = 0x935E,
       |    GL_ZERO_TO_ONE                    = 0x935F,
       |    GL_CLIP_ORIGIN                    = 0x935C,
       |    GL_CLIP_DEPTH_MODE                = 0x935D,
       |
       |    // ARB_cull_distance
       |    GL_MAX_CULL_DISTANCES             = 0x82F9,
       |    GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES = 0x82FA,
       |
       |    // ARB_conditional_render_inverted
       |    GL_QUERY_WAIT_INVERTED            = 0x8E17,
       |    GL_QUERY_NO_WAIT_INVERTED         = 0x8E18,
       |    GL_QUERY_BY_REGION_WAIT_INVERTED  = 0x8E19,
       |    GL_QUERY_BY_REGION_NO_WAIT_INVERTED = 0x8E1A,
       |
       |    // KHR_context_flush_control
       |    GL_CONTEXT_RELEASE_BEHAVIOR       = 0x82FB,
       |    GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 0x82FC,
       |
       |    // ARB_direct_state_access
       |    GL_TEXTURE_TARGET = 0x1006,
       |    GL_QUERY_TARGET = 0x82EA,
       |
       |    // KHR_robustness
       |    GL_GUILTY_CONTEXT_RESET           = 0x8253,
       |    GL_INNOCENT_CONTEXT_RESET         = 0x8254,
       |    GL_UNKNOWN_CONTEXT_RESET          = 0x8255,
       |    GL_CONTEXT_ROBUST_ACCESS          = 0x90F3,
       |    GL_RESET_NOTIFICATION_STRATEGY    = 0x8256,
       |    GL_LOSE_CONTEXT_ON_RESET          = 0x8252,
       |    GL_NO_RESET_NOTIFICATION          = 0x8261,
       |    GL_CONTEXT_LOST                   = 0x0507,
       |}
       |
       |private __gshared bool _ARB_depth_buffer_float;
0000000|@nogc bool ARB_depth_buffer_float() nothrow @property { return _ARB_depth_buffer_float; }
       |
       |private __gshared bool _ARB_framebuffer_sRGB;
0000000|@nogc bool ARB_framebuffer_sRGB() nothrow @property { return _ARB_framebuffer_sRGB; }
       |
       |// ARB_geometry_shader4
       |extern(System) @nogc nothrow {
       |    alias da_glProgramParameteriARB = void function(GLuint, GLenum, GLint);
       |    alias da_glFramebufferTextureARB = void function(GLuint, GLenum, GLuint, GLint);
       |    alias da_glFramebufferTextureLayerARB = void function(GLuint, GLenum, GLuint, GLint, GLint);
       |    alias da_glFramebufferTextureFaceARB = void function(GLuint, GLenum, GLuint, GLint, GLenum);
       |}
       |
       |__gshared
       |{
       |    da_glProgramParameteriARB glProgramParameteriARB;
       |    da_glFramebufferTextureARB glFramebufferTextureARB;
       |    da_glFramebufferTextureLayerARB glFramebufferTextureLayerARB;
       |    da_glFramebufferTextureFaceARB glFramebufferTextureFaceARB;
       |}
       |
       |private __gshared bool _ARB_geometry_shader4;
0000000|@nogc bool ARB_geometry_shader4() nothrow @property { return _ARB_geometry_shader4; }
       |package void load_ARB_geometry_shader4(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glProgramParameteriARB, "glProgramParameteriARB");
0000000|        bindGLFunc(cast(void**)&glFramebufferTextureARB, "glFramebufferTextureARB");
0000000|        bindGLFunc(cast(void**)&glFramebufferTextureLayerARB, "glFramebufferTextureLayerARB");
0000000|        bindGLFunc(cast(void**)&glFramebufferTextureFaceARB, "glFramebufferTextureFaceARB");
0000000|        _ARB_geometry_shader4 = true;
       |    } catch(Exception e) {
0000000|        _ARB_geometry_shader4 = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |private __gshared bool _ARB_half_float_vertex;
0000000|@nogc bool ARB_half_float_vertex() nothrow @property { return _ARB_half_float_vertex; }
       |
       |private __gshared bool _ARB_imaging;
0000000|@nogc bool ARB_imaging() nothrow @property { return _ARB_imaging; }
       |
       |private __gshared bool _ARB_texture_compression_rgtc;
0000000|@nogc bool ARB_texture_compression_rgtc() nothrow @property { return _ARB_texture_compression_rgtc; }
       |
       |private __gshared bool _ARB_texture_rg;
0000000|@nogc bool ARB_texture_rg() nothrow @property { return _ARB_texture_rg; }
       |
       |private __gshared bool _ARB_depth_clamp;
0000000|@nogc bool ARB_depth_clamp() nothrow @property { return _ARB_depth_clamp; }
       |
       |private __gshared bool _ARB_fragment_coord_conventions;
0000000|@nogc bool ARB_fragment_coord_conventions() nothrow @property { return _ARB_fragment_coord_conventions; }
       |
       |private __gshared bool _ARB_seamless_cube_map;
0000000|@nogc bool ARB_seamless_cube_map() nothrow @property { return _ARB_seamless_cube_map; }
       |
       |private __gshared bool _ARB_vertex_array_bgra;
0000000|@nogc bool ARB_vertex_array_bgra() nothrow @property { return _ARB_vertex_array_bgra; }
       |
       |private __gshared bool _ARB_texture_cube_map_array;
0000000|@nogc bool ARB_texture_cube_map_array() nothrow @property { return _ARB_texture_cube_map_array; }
       |
       |private __gshared bool _ARB_texture_gather;
0000000|@nogc bool ARB_texture_gather() nothrow @property { return _ARB_texture_gather; }
       |
       |private __gshared bool _ARB_texture_query_lod;
0000000|@nogc bool ARB_texture_query_lod() nothrow @property { return _ARB_texture_query_lod; }
       |
       |private __gshared bool _ARB_texture_compression_bptc;
0000000|@nogc bool ARB_texture_compression_bptc() nothrow @property { return _ARB_texture_compression_bptc; }
       |
       |private __gshared bool _ARB_explicit_attrib_location;
0000000|@nogc bool ARB_explicit_attrib_location() nothrow @property { return _ARB_explicit_attrib_location; }
       |
       |private __gshared bool _ARB_occlusion_query2;
0000000|@nogc bool ARB_occlusion_query2() nothrow @property { return _ARB_occlusion_query2; }
       |
       |private __gshared bool _ARB_shader_bit_encoding;
0000000|@nogc bool ARB_shader_bit_encoding() nothrow @property { return _ARB_shader_bit_encoding; }
       |
       |private __gshared bool _ARB_texture_rgb10_a2ui;
0000000|@nogc bool ARB_texture_rgb10_a2ui() nothrow @property { return _ARB_texture_rgb10_a2ui; }
       |
       |private __gshared bool _ARB_texture_swizzle;
0000000|@nogc bool ARB_texture_swizzle() nothrow @property { return _ARB_texture_swizzle; }
       |
       |private __gshared bool _ARB_gpu_shader5;
0000000|@nogc bool ARB_gpu_shader5() nothrow @property { return _ARB_gpu_shader5; }
       |
       |private __gshared bool _ARB_texture_buffer_object_rgb32;
0000000|@nogc bool ARB_texture_buffer_object_rgb32() nothrow @property { return _ARB_texture_buffer_object_rgb32; }
       |
       |private __gshared bool _ARB_shader_precision;
0000000|@nogc bool ARB_shader_precision() nothrow @property { return _ARB_shader_precision; }
       |
       |private __gshared bool _ARB_shader_stencil_export;
0000000|@nogc bool ARB_shader_stencil_export() nothrow @property { return _ARB_shader_stencil_export; }
       |
       |private __gshared bool _ARB_shading_language_420pack;
0000000|@nogc bool ARB_shading_language_420pack() nothrow @property { return _ARB_shading_language_420pack; }
       |
       |private __gshared bool _ARB_compressed_texture_pixel_storage;
0000000|@nogc bool ARB_compressed_texture_pixel_storage() nothrow @property { return _ARB_compressed_texture_pixel_storage; }
       |
       |private __gshared bool _ARB_conservative_depth;
0000000|@nogc bool ARB_conservative_depth() nothrow @property { return _ARB_conservative_depth; }
       |
       |private __gshared bool _ARB_map_buffer_alignment;
0000000|@nogc bool ARB_map_buffer_alignment() nothrow @property { return _ARB_map_buffer_alignment; }
       |
       |private __gshared bool _ARB_shading_language_packing;
0000000|@nogc bool ARB_shading_language_packing() nothrow @property { return _ARB_shading_language_packing; }
       |
       |// ARB_framebuffer_object
       |extern(System) @nogc nothrow {
       |    alias da_glIsRenderbuffer = GLboolean function(GLuint);
       |    alias da_glBindRenderbuffer = void function(GLenum, GLuint);
       |    alias da_glDeleteRenderbuffers = void function(GLsizei, const(GLuint)*);
       |    alias da_glGenRenderbuffers = void function(GLsizei, GLuint*);
       |    alias da_glRenderbufferStorage = void function(GLenum, GLenum, GLsizei, GLsizei);
       |    alias da_glGetRenderbufferParameteriv = void function(GLenum, GLenum, GLint*);
       |    alias da_glIsFramebuffer = GLboolean function(GLuint);
       |    alias da_glBindFramebuffer = void function(GLenum, GLuint);
       |    alias da_glDeleteFramebuffers = void function(GLsizei, const(GLuint)*);
       |    alias da_glGenFramebuffers = void function(GLsizei, GLuint*);
       |    alias da_glCheckFramebufferStatus = GLenum function(GLenum);
       |    alias da_glFramebufferTexture1D = void function(GLenum, GLenum, GLenum, GLuint, GLint);
       |    alias da_glFramebufferTexture2D = void function(GLenum, GLenum, GLenum, GLuint, GLint);
       |    alias da_glFramebufferTexture3D = void function(GLenum, GLenum, GLenum, GLuint, GLint, GLint);
       |    alias da_glFramebufferRenderbuffer = void function(GLenum, GLenum, GLenum, GLuint);
       |    alias da_glGetFramebufferAttachmentParameteriv = void function(GLenum, GLenum, GLenum, GLint*);
       |    alias da_glGenerateMipmap = void function(GLenum);
       |    alias da_glBlitFramebuffer = void function(GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLint, GLbitfield, GLenum);
       |    alias da_glRenderbufferStorageMultisample = void function(GLenum, GLsizei, GLenum, GLsizei, GLsizei);
       |    alias da_glFramebufferTextureLayer = void function(GLenum, GLenum, GLuint, GLint, GLint);
       |}
       |
       |__gshared
       |{
       |    da_glIsRenderbuffer glIsRenderbuffer;
       |    da_glBindRenderbuffer glBindRenderbuffer;
       |    da_glDeleteRenderbuffers glDeleteRenderbuffers;
       |    da_glGenRenderbuffers glGenRenderbuffers;
       |    da_glRenderbufferStorage glRenderbufferStorage;
       |    da_glGetRenderbufferParameteriv glGetRenderbufferParameteriv;
       |    da_glIsFramebuffer glIsFramebuffer;
       |    da_glBindFramebuffer glBindFramebuffer;
       |    da_glDeleteFramebuffers glDeleteFramebuffers;
       |    da_glGenFramebuffers glGenFramebuffers;
       |    da_glCheckFramebufferStatus glCheckFramebufferStatus;
       |    da_glFramebufferTexture1D glFramebufferTexture1D;
       |    da_glFramebufferTexture2D glFramebufferTexture2D;
       |    da_glFramebufferTexture3D glFramebufferTexture3D;
       |    da_glFramebufferRenderbuffer glFramebufferRenderbuffer;
       |    da_glGetFramebufferAttachmentParameteriv glGetFramebufferAttachmentParameteriv;
       |    da_glGenerateMipmap glGenerateMipmap;
       |    da_glBlitFramebuffer glBlitFramebuffer;
       |    da_glRenderbufferStorageMultisample glRenderbufferStorageMultisample;
       |    da_glFramebufferTextureLayer glFramebufferTextureLayer;
       |}
       |
       |private __gshared bool _ARB_framebuffer_object;
0000000|@nogc bool ARB_framebuffer_object() nothrow @property { return _ARB_framebuffer_object; }
       |package void load_ARB_framebuffer_object(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glIsRenderbuffer, "glIsRenderbuffer");
0000000|        bindGLFunc(cast(void**)&glBindRenderbuffer, "glBindRenderbuffer");
0000000|        bindGLFunc(cast(void**)&glDeleteRenderbuffers, "glDeleteRenderbuffers");
0000000|        bindGLFunc(cast(void**)&glGenRenderbuffers, "glGenRenderbuffers");
0000000|        bindGLFunc(cast(void**)&glRenderbufferStorage, "glRenderbufferStorage");
0000000|        bindGLFunc(cast(void**)&glGetRenderbufferParameteriv, "glGetRenderbufferParameteriv");
0000000|        bindGLFunc(cast(void**)&glIsFramebuffer, "glIsFramebuffer");
0000000|        bindGLFunc(cast(void**)&glBindFramebuffer, "glBindFramebuffer");
0000000|        bindGLFunc(cast(void**)&glDeleteFramebuffers, "glDeleteFramebuffers");
0000000|        bindGLFunc(cast(void**)&glGenFramebuffers, "glGenFramebuffers");
0000000|        bindGLFunc(cast(void**)&glCheckFramebufferStatus, "glCheckFramebufferStatus");
0000000|        bindGLFunc(cast(void**)&glFramebufferTexture1D, "glFramebufferTexture1D");
0000000|        bindGLFunc(cast(void**)&glFramebufferTexture2D, "glFramebufferTexture2D");
0000000|        bindGLFunc(cast(void**)&glFramebufferTexture3D, "glFramebufferTexture3D");
0000000|        bindGLFunc(cast(void**)&glFramebufferRenderbuffer, "glFramebufferRenderbuffer");
0000000|        bindGLFunc(cast(void**)&glGetFramebufferAttachmentParameteriv, "glGetFramebufferAttachmentParameteriv");
0000000|        bindGLFunc(cast(void**)&glGenerateMipmap, "glGenerateMipmap");
0000000|        bindGLFunc(cast(void**)&glBlitFramebuffer, "glBlitFramebuffer");
0000000|        bindGLFunc(cast(void**)&glRenderbufferStorageMultisample, "glRenderbufferStorageMultisample");
0000000|        bindGLFunc(cast(void**)&glFramebufferTextureLayer, "glFramebufferTextureLayer");
0000000|        _ARB_framebuffer_object = true;
       |    } catch(Exception e) {
0000000|        _ARB_framebuffer_object = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_map_buffer_range
       |extern(System) @nogc nothrow {
       |        alias da_glMapBufferRange = GLvoid* function(GLenum, GLintptr, GLsizeiptr, GLbitfield);
       |        alias da_glFlushMappedBufferRange = void function(GLenum, GLintptr, GLsizeiptr);
       |}
       |__gshared da_glMapBufferRange glMapBufferRange;
       |__gshared da_glFlushMappedBufferRange glFlushMappedBufferRange;
       |
       |private __gshared bool _ARB_map_buffer_range;
0000000|@nogc bool ARB_map_buffer_range() nothrow @property { return _ARB_map_buffer_range; }
       |package void load_ARB_map_buffer_range(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glMapBufferRange, "glMapBufferRange");
0000000|        bindGLFunc(cast(void**)&glFlushMappedBufferRange, "glFlushMappedBufferRange");
0000000|        _ARB_map_buffer_range = true;
       |    } catch(Exception e) {
0000000|        _ARB_map_buffer_range = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_vertex_array_object
       |extern(System) @nogc nothrow {
       |    alias da_glBindVertexArray = void function(GLuint);
       |    alias da_glDeleteVertexArrays = void function(GLsizei, const(GLuint)*);
       |    alias da_glGenVertexArrays = void function(GLsizei, GLuint*);
       |    alias da_glIsVertexArray = GLboolean function(GLuint);
       |}
       |
       |__gshared {
       |    da_glBindVertexArray glBindVertexArray;
       |    da_glDeleteVertexArrays glDeleteVertexArrays;
       |    da_glGenVertexArrays glGenVertexArrays;
       |    da_glIsVertexArray glIsVertexArray;
       |}
       |
       |private __gshared bool _ARB_vertex_array_object;
0000000|@nogc bool ARB_vertex_array_object() nothrow @property { return _ARB_vertex_array_object; }
       |package void load_ARB_vertex_array_object(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glBindVertexArray, "glBindVertexArray");
0000000|        bindGLFunc(cast(void**)&glDeleteVertexArrays, "glDeleteVertexArrays");
0000000|        bindGLFunc(cast(void**)&glGenVertexArrays, "glGenVertexArrays");
0000000|        bindGLFunc(cast(void**)&glIsVertexArray, "glIsVertexArray");
0000000|        _ARB_vertex_array_object = true;
       |    } catch(Exception e) {
0000000|        _ARB_vertex_array_object = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_uniform_buffer_object
       |extern(System) @nogc nothrow {
       |    alias da_glGetUniformIndices = void function(GLuint, GLsizei, const(GLchar*)*, GLuint*);
       |    alias da_glGetActiveUniformsiv = void function(GLuint, GLsizei, const(GLuint)*, GLenum, GLint*);
       |    alias da_glGetActiveUniformName = void function(GLuint, GLuint, GLsizei, GLsizei*, GLchar*);
       |    alias da_glGetUniformBlockIndex = GLuint function(GLuint, const(GLchar)*);
       |    alias da_glGetActiveUniformBlockiv = void function(GLuint, GLuint, GLenum, GLint*);
       |    alias da_glGetActiveUniformBlockName = void function(GLuint, GLuint, GLsizei, GLsizei*, GLchar*);
       |    alias da_glUniformBlockBinding = void function(GLuint, GLuint, GLuint);
       |}
       |
       |__gshared {
       |    da_glGetUniformIndices glGetUniformIndices;
       |    da_glGetActiveUniformsiv glGetActiveUniformsiv;
       |    da_glGetActiveUniformName glGetActiveUniformName;
       |    da_glGetUniformBlockIndex glGetUniformBlockIndex;
       |    da_glGetActiveUniformBlockiv glGetActiveUniformBlockiv;
       |    da_glGetActiveUniformBlockName glGetActiveUniformBlockName;
       |    da_glUniformBlockBinding glUniformBlockBinding;
       |}
       |
       |private __gshared bool _ARB_uniform_buffer_object;
0000000|@nogc bool ARB_uniform_buffer_object() nothrow @property { return _ARB_uniform_buffer_object; }
       |package void load_ARB_uniform_buffer_object(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glGetUniformIndices, "glGetUniformIndices");
0000000|        bindGLFunc(cast(void**)&glGetActiveUniformsiv, "glGetActiveUniformsiv");
0000000|        bindGLFunc(cast(void**)&glGetActiveUniformName, "glGetActiveUniformName");
0000000|        bindGLFunc(cast(void**)&glGetUniformBlockIndex, "glGetUniformBlockIndex");
0000000|        bindGLFunc(cast(void**)&glGetActiveUniformBlockiv, "glGetActiveUniformBlockiv");
0000000|        bindGLFunc(cast(void**)&glGetActiveUniformBlockName, "glGetActiveUniformBlockName");
0000000|        bindGLFunc(cast(void**)&glUniformBlockBinding, "glUniformBlockBinding");
0000000|        _ARB_uniform_buffer_object = true;
       |    } catch(Exception e) {
0000000|        _ARB_uniform_buffer_object = true;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_copy_buffer
       |extern(System) @nogc nothrow alias da_glCopyBufferSubData = void function(GLenum, GLenum, GLintptr, GLintptr, GLsizeiptr);
       |__gshared da_glCopyBufferSubData glCopyBufferSubData;
       |
       |private __gshared bool _ARB_copy_buffer;
0000000|@nogc bool ARB_copy_buffer() nothrow @property { return _ARB_copy_buffer; }
       |package void load_ARB_copy_buffer(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glCopyBufferSubData, "glCopyBufferSubData");
0000000|        _ARB_copy_buffer = true;
       |    } catch(Exception e) {
0000000|        _ARB_copy_buffer = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_draw_elements_base_vertex
       |extern(System) @nogc nothrow {
       |    alias da_glDrawElementsBaseVertex = void function(GLenum, GLsizei, GLenum, const(GLvoid)*, GLint);
       |    alias da_glDrawRangeElementsBaseVertex = void function(GLenum, GLuint, GLuint, GLsizei, GLenum, const(GLvoid)*, GLint);
       |    alias da_glDrawElementsInstancedBaseVertex = void function(GLenum, GLsizei, GLenum, const(GLvoid)*, GLsizei, GLint);
       |    alias da_glMultiDrawElementsBaseVertex = void function(GLenum, const(GLsizei)*, GLenum, const(GLvoid*)*, GLsizei, const(GLint)*);
       |}
       |
       |__gshared {
       |    da_glDrawElementsBaseVertex glDrawElementsBaseVertex;
       |    da_glDrawRangeElementsBaseVertex glDrawRangeElementsBaseVertex;
       |    da_glDrawElementsInstancedBaseVertex glDrawElementsInstancedBaseVertex;
       |    da_glMultiDrawElementsBaseVertex glMultiDrawElementsBaseVertex;
       |}
       |
       |private __gshared bool _ARB_draw_elements_base_vertex;
0000000|@nogc bool ARB_draw_elements_base_vertex() nothrow @property { return _ARB_draw_elements_base_vertex; }
       |package void load_ARB_draw_elements_base_vertex(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glDrawElementsBaseVertex, "glDrawElementsBaseVertex");
0000000|        bindGLFunc(cast(void**)&glDrawRangeElementsBaseVertex, "glDrawRangeElementsBaseVertex");
0000000|        bindGLFunc(cast(void**)&glDrawElementsInstancedBaseVertex, "glDrawElementsInstancedBaseVertex");
0000000|        bindGLFunc(cast(void**)&glMultiDrawElementsBaseVertex, "glMultiDrawElementsBaseVertex");
0000000|        _ARB_draw_elements_base_vertex = true;
       |    } catch(Exception e) {
0000000|        _ARB_draw_elements_base_vertex = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_provoking_vertex
       |extern(System) @nogc nothrow alias da_glProvokingVertex = void function(GLenum);
       |__gshared da_glProvokingVertex glProvokingVertex;
       |
       |private __gshared bool _ARB_provoking_vertex;
0000000|@nogc bool ARB_provoking_vertex() nothrow @property { return _ARB_provoking_vertex; }
       |package void load_ARB_provoking_vertex(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glProvokingVertex, "glProvokingVertex");
0000000|        _ARB_provoking_vertex = true;
       |    } catch(Exception e) {
0000000|        _ARB_provoking_vertex = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_sync
       |extern(System) @nogc nothrow {
       |    alias da_glFenceSync = GLsync function(GLenum, GLbitfield);
       |    alias da_glIsSync = GLboolean function(GLsync);
       |    alias da_glDeleteSync = void function(GLsync);
       |    alias da_glClientWaitSync = GLenum function(GLsync, GLbitfield, GLuint64);
       |    alias da_glWaitSync = void function(GLsync, GLbitfield, GLuint64);
       |    alias da_glGetInteger64v = void function(GLsync, GLint64*);
       |    alias da_glGetSynciv = void function(GLsync, GLenum, GLsizei, GLsizei*, GLint*);
       |}
       |
       |__gshared {
       |    da_glFenceSync glFenceSync;
       |    da_glIsSync glIsSync;
       |    da_glDeleteSync glDeleteSync;
       |    da_glClientWaitSync glClientWaitSync;
       |    da_glWaitSync glWaitSync;
       |    da_glGetInteger64v glGetInteger64v;
       |    da_glGetSynciv glGetSynciv;
       |}
       |
       |private __gshared bool _ARB_sync;
0000000|@nogc bool ARB_sync() nothrow @property { return _ARB_sync; }
       |package void load_ARB_sync(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glFenceSync, "glFenceSync");
0000000|        bindGLFunc(cast(void**)&glIsSync, "glIsSync");
0000000|        bindGLFunc(cast(void**)&glDeleteSync, "glDeleteSync");
0000000|        bindGLFunc(cast(void**)&glClientWaitSync, "glClientWaitSync");
0000000|        bindGLFunc(cast(void**)&glWaitSync, "glWaitSync");
0000000|        bindGLFunc(cast(void**)&glGetInteger64v, "glGetInteger64v");
0000000|        bindGLFunc(cast(void**)&glGetSynciv, "glGetSynciv");
0000000|        _ARB_sync = true;
       |    } catch(Exception e) {
0000000|        _ARB_sync = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_texture_multisample
       |extern(System) @nogc nothrow {
       |    alias da_glTexImage2DMultisample = void function(GLenum, GLsizei, GLint, GLsizei, GLsizei, GLboolean);
       |    alias da_glTexImage3DMultisample = void function(GLenum, GLsizei, GLint, GLsizei, GLsizei, GLsizei, GLboolean);
       |    alias da_glGetMultisamplefv = void function(GLenum, GLuint, GLfloat*);
       |    alias da_glSampleMaski = void function(GLuint, GLbitfield);
       |}
       |
       |__gshared {
       |    da_glTexImage2DMultisample glTexImage2DMultisample;
       |    da_glTexImage3DMultisample glTexImage3DMultisample;
       |    da_glGetMultisamplefv glGetMultisamplefv;
       |    da_glSampleMaski glSampleMaski;
       |}
       |
       |private __gshared bool _ARB_texture_multisample;
0000000|@nogc bool ARB_texture_multisample() nothrow @property { return _ARB_texture_multisample; }
       |package void load_ARB_texture_multisample(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glTexImage2DMultisample, "glTexImage2DMultisample");
0000000|        bindGLFunc(cast(void**)&glTexImage3DMultisample, "glTexImage3DMultisample");
0000000|        bindGLFunc(cast(void**)&glGetMultisamplefv, "glGetMultisamplefv");
0000000|        bindGLFunc(cast(void**)&glSampleMaski, "glSampleMaski");
0000000|        _ARB_texture_multisample = true;
       |    } catch(Exception e) {
0000000|        _ARB_texture_multisample = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_draw_buffers_blend
       |extern(System) @nogc nothrow {
       |    alias da_glBlendEquationiARB = void function(GLuint, GLenum);
       |    alias da_glBlendEquationSeparateiARB = void function(GLuint, GLenum, GLenum);
       |    alias da_glBlendFunciARB = void function(GLuint, GLenum, GLenum);
       |    alias da_glBlendFuncSeparateiARB = void function(GLuint, GLenum, GLenum, GLenum, GLenum);
       |}
       |
       |__gshared {
       |    da_glBlendEquationiARB glBlendEquationiARB;
       |    da_glBlendEquationSeparateiARB glBlendEquationSeparateiARB;
       |    da_glBlendFunciARB glBlendFunciARB;
       |    da_glBlendFuncSeparateiARB glBlendFuncSeparateiARB;
       |}
       |
       |private __gshared bool _ARB_draw_buffers_blend;
0000000|@nogc bool ARB_draw_buffers_blend() nothrow @property { return _ARB_draw_buffers_blend; }
       |package void load_ARB_draw_buffers_blend() {
       |    try {
0000000|        bindGLFunc(cast(void**)&glBlendEquationiARB, "glBlendEquationiARB");
0000000|        bindGLFunc(cast(void**)&glBlendEquationSeparateiARB, "glBlendEquationSeparateiARB");
0000000|        bindGLFunc(cast(void**)&glBlendFunciARB, "glBlendFunciARB");
0000000|        bindGLFunc(cast(void**)&glBlendFuncSeparateiARB, "glBlendFuncSeparateiARB");
0000000|        _ARB_draw_buffers_blend = true;
       |    } catch(Exception e) {
0000000|        _ARB_draw_buffers_blend = false;
       |    }
       |}
       |
       |// ARB_sample_shading
       |extern(System) @nogc nothrow alias da_glMinSampleShadingARB = void function(GLclampf);
       |__gshared da_glMinSampleShadingARB glMinSampleShadingARB;
       |
       |private __gshared bool _ARB_sample_shading;
0000000|@nogc bool ARB_sample_shading() nothrow @property { return _ARB_sample_shading; }
       |package void load_ARB_sample_shading() {
       |    try {
0000000|        bindGLFunc(cast(void**)&glMinSampleShadingARB, "glMinSampleShadingARB");
0000000|        _ARB_sample_shading = true;
       |    } catch(Exception e) {
0000000|        _ARB_sample_shading = false;
       |    }
       |}
       |
       |// ARB_shading_language_include
       |extern(System) @nogc nothrow {
       |    alias da_glNamedStringARB = void function(GLenum, GLint, const(GLchar)*, GLint, const(GLchar)*);
       |    alias da_glDeleteNamedStringARB = void function(GLint, const(GLchar)*);
       |    alias da_glCompileShaderIncludeARB = void function(GLuint, GLsizei, const(GLchar)*, const(GLint)*);
       |    alias da_glIsNamedStringARB = GLboolean function(GLint, const(GLchar)*);
       |    alias da_glGetNamedStringARB = void function(GLint, const(GLchar)*, GLsizei, GLint*, GLchar*);
       |    alias da_glGetNamedStringivARB = void function(GLint, const(GLchar)*, GLenum, GLint*);
       |}
       |
       |__gshared {
       |    da_glNamedStringARB glNamedStringARB;
       |    da_glDeleteNamedStringARB glDeleteNamedStringARB;
       |    da_glCompileShaderIncludeARB glCompileShaderIncludeARB;
       |    da_glIsNamedStringARB glIsNamedStringARB;
       |    da_glGetNamedStringARB glGetNamedStringARB;
       |    da_glGetNamedStringivARB glGetNamedStringivARB;
       |}
       |
       |private __gshared bool _ARB_shading_language_include;
0000000|@nogc bool ARB_shading_language_include() nothrow @property { return _ARB_shading_language_include; }
       |package void load_ARB_shading_language_include() {
       |    try {
0000000|        bindGLFunc(cast(void**)&glNamedStringARB, "glNamedStringARB");
0000000|        bindGLFunc(cast(void**)&glDeleteNamedStringARB, "glDeleteNamedStringARB");
0000000|        bindGLFunc(cast(void**)&glCompileShaderIncludeARB, "glCompileShaderIncludeARB");
0000000|        bindGLFunc(cast(void**)&glIsNamedStringARB, "glIsNamedStringARB");
0000000|        bindGLFunc(cast(void**)&glGetNamedStringARB, "glGetNamedStringARB");
0000000|        bindGLFunc(cast(void**)&glGetNamedStringivARB, "glGetNamedStringivARB");
0000000|        _ARB_shading_language_include = true;
       |    } catch(Exception e) {
0000000|        _ARB_shading_language_include = false;
       |    }
       |}
       |
       |// ARB_blend_func_extended
       |extern(System) @nogc nothrow {
       |    alias da_glBindFragDataLocationIndexed = void function(GLuint, GLuint, GLuint, const(GLchar)*);
       |    alias da_glGetFragDataIndex = GLint function(GLuint, const(GLchar)*);
       |}
       |
       |__gshared da_glBindFragDataLocationIndexed glBindFragDataLocationIndexed;
       |__gshared da_glGetFragDataIndex glGetFragDataIndex;
       |
       |private __gshared bool _ARB_blend_func_extended;
0000000|@nogc bool ARB_blend_func_extended() nothrow @property { return _ARB_blend_func_extended; }
       |package void load_ARB_blend_func_extended(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glBindFragDataLocationIndexed, "glBindFragDataLocationIndexed");
0000000|        bindGLFunc(cast(void**)&glGetFragDataIndex, "glGetFragDataIndex");
0000000|        _ARB_blend_func_extended = true;
       |    } catch(Exception e) {
0000000|        _ARB_blend_func_extended = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_sampler_objects
       |extern(System) @nogc nothrow {
       |    alias da_glGenSamplers = void function(GLsizei, GLuint*);
       |    alias da_glDeleteSamplers = void function(GLsizei, const(GLuint)*);
       |    alias da_glIsSampler = GLboolean function(GLuint);
       |    alias da_glBindSampler = void function(GLuint, GLuint);
       |    alias da_glSamplerParameteri = void function(GLuint, GLenum, GLint);
       |    alias da_glSamplerParameteriv = void function(GLuint, GLenum, const(GLint)*);
       |    alias da_glSamplerParameterf = void function(GLuint, GLenum, GLfloat);
       |    alias da_glSamplerParameterfv = void function(GLuint, GLenum, const(GLfloat)*);
       |    alias da_glSamplerParameterIiv = void function(GLuint, GLenum, const(GLint)*);
       |    alias da_glSamplerParameterIuiv = void function(GLuint, GLenum, const(GLuint)*);
       |    alias da_glGetSamplerParameteriv = void function(GLuint, GLenum, GLint*);
       |    alias da_glGetSamplerParameterIiv = void function(GLuint, GLenum, GLint*);
       |    alias da_glGetSamplerParameterfv = void function(GLuint, GLenum, GLfloat*);
       |    alias da_glGetSamplerParameterIuiv = void function(GLuint, GLenum, GLuint*);
       |}
       |
       |__gshared {
       |    da_glGenSamplers glGenSamplers;
       |    da_glDeleteSamplers glDeleteSamplers;
       |    da_glIsSampler glIsSampler;
       |    da_glBindSampler glBindSampler;
       |    da_glSamplerParameteri glSamplerParameteri;
       |    da_glSamplerParameteriv glSamplerParameteriv;
       |    da_glSamplerParameterf glSamplerParameterf;
       |    da_glSamplerParameterfv glSamplerParameterfv;
       |    da_glSamplerParameterIiv glSamplerParameterIiv;
       |    da_glSamplerParameterIuiv glSamplerParameterIuiv;
       |    da_glGetSamplerParameteriv glGetSamplerParameteriv;
       |    da_glGetSamplerParameterIiv glGetSamplerParameterIiv;
       |    da_glGetSamplerParameterfv glGetSamplerParameterfv;
       |    da_glGetSamplerParameterIuiv glGetSamplerParameterIuiv;
       |}
       |
       |private __gshared bool _ARB_sampler_objects;
0000000|@nogc bool ARB_sampler_objects() nothrow @property { return _ARB_sampler_objects; }
       |package void load_ARB_sampler_objects(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glGenSamplers, "glGenSamplers");
0000000|        bindGLFunc(cast(void**)&glDeleteSamplers, "glDeleteSamplers");
0000000|        bindGLFunc(cast(void**)&glIsSampler, "glIsSampler");
0000000|        bindGLFunc(cast(void**)&glBindSampler, "glBindSampler");
0000000|        bindGLFunc(cast(void**)&glSamplerParameteri, "glSamplerParameteri");
0000000|        bindGLFunc(cast(void**)&glSamplerParameteriv, "glSamplerParameteriv");
0000000|        bindGLFunc(cast(void**)&glSamplerParameterf, "glSamplerParameterf");
0000000|        bindGLFunc(cast(void**)&glSamplerParameterfv, "glSamplerParameterfv");
0000000|        bindGLFunc(cast(void**)&glSamplerParameterIiv, "glSamplerParameterIiv");
0000000|        bindGLFunc(cast(void**)&glSamplerParameterIuiv, "glSamplerParameterIuiv");
0000000|        bindGLFunc(cast(void**)&glGetSamplerParameteriv, "glGetSamplerParameteriv");
0000000|        bindGLFunc(cast(void**)&glGetSamplerParameterIiv, "glGetSamplerParameterIiv");
0000000|        bindGLFunc(cast(void**)&glGetSamplerParameterfv, "glGetSamplerParameterfv");
0000000|        bindGLFunc(cast(void**)&glGetSamplerParameterIuiv, "glGetSamplerParameterIuiv");
0000000|        _ARB_sampler_objects = true;
       |    } catch(Exception e) {
0000000|        _ARB_sampler_objects = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_timer_query
       |extern(System) @nogc nothrow {
       |    alias da_glQueryCounter = void function(GLuint, GLenum);
       |    alias da_glGetQueryObjecti64v = void function(GLuint, GLenum, GLint64*);
       |    alias da_glGetQueryObjectui64v = void function(GLuint, GLenum, GLuint64*);
       |}
       |
       |__gshared {
       |    da_glQueryCounter glQueryCounter;
       |    da_glGetQueryObjecti64v glGetQueryObjecti64v;
       |    da_glGetQueryObjectui64v glGetQueryObjectui64v;
       |}
       |
       |private __gshared bool _ARB_timer_query;
0000000|@nogc bool ARB_timer_query() nothrow @property { return _ARB_timer_query; }
       |void load_ARB_timer_query(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glQueryCounter, "glQueryCounter");
0000000|        bindGLFunc(cast(void**)&glGetQueryObjecti64v, "glGetQueryObjecti64v");
0000000|        bindGLFunc(cast(void**)&glGetQueryObjectui64v, "glGetQueryObjectui64v");
0000000|        _ARB_timer_query = true;
       |    } catch(Exception e) {
0000000|        _ARB_timer_query = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_vertex_type_2_10_10_10_rev
       |extern(System) @nogc nothrow {
       |    alias da_glVertexP2ui = void function(GLenum, GLuint);
       |    alias da_glVertexP2uiv = void function(GLenum, const(GLuint)*);
       |    alias da_glVertexP3ui = void function(GLenum, GLuint);
       |    alias da_glVertexP3uiv = void function(GLenum, const(GLuint)*);
       |    alias da_glVertexP4ui = void function(GLenum, GLuint);
       |    alias da_glVertexP4uiv = void function(GLenum, const(GLuint)*);
       |    alias da_glTexCoordP1ui = void function(GLenum, GLuint);
       |    alias da_glTexCoordP1uiv = void function(GLenum, const(GLuint)*);
       |    alias da_glTexCoordP2ui = void function(GLenum, GLuint);
       |    alias da_glTexCoordP2uiv = void function(GLenum, const(GLuint)*);
       |    alias da_glTexCoordP3ui = void function(GLenum, GLuint);
       |    alias da_glTexCoordP3uiv = void function(GLenum, const(GLuint)*);
       |    alias da_glTexCoordP4ui = void function(GLenum, GLuint);
       |    alias da_glTexCoordP4uiv = void function(GLenum, const(GLuint)*);
       |    alias da_glMultiTexCoordP1ui = void function(GLenum, GLenum, GLuint);
       |    alias da_glMultiTexCoordP1uiv = void function(GLenum, GLenum, const(GLuint)*);
       |    alias da_glMultiTexCoordP2ui = void function(GLenum, GLenum, GLuint);
       |    alias da_glMultiTexCoordP2uiv = void function(GLenum, GLenum, const(GLuint)*);
       |    alias da_glMultiTexCoordP3ui = void function(GLenum, GLenum, GLuint);
       |    alias da_glMultiTexCoordP3uiv = void function(GLenum, GLenum, const(GLuint)*);
       |    alias da_glMultiTexCoordP4ui = void function(GLenum, GLenum, GLuint);
       |    alias da_glMultiTexCoordP4uiv = void function(GLenum, GLenum, const(GLuint)*);
       |    alias da_glNormalP3ui = void function(GLenum, GLuint);
       |    alias da_glNormalP3uiv = void function(GLenum, const(GLuint)*);
       |    alias da_glColorP3ui = void function(GLenum, GLuint);
       |    alias da_glColorP3uiv = void function(GLenum, const(GLuint)*);
       |    alias da_glColorP4ui = void function(GLenum, GLuint);
       |    alias da_glColorP4uiv = void function(GLenum, const(GLuint)*);
       |    alias da_glSecondaryColorP3ui = void function(GLenum, GLuint);
       |    alias da_glSecondaryColorP3uiv = void function(GLenum, const(GLuint)*);
       |    alias da_glVertexAttribP1ui = void function(GLuint, GLenum, GLboolean, GLuint);
       |    alias da_glVertexAttribP1uiv = void function(GLuint, GLenum, GLboolean, const(GLuint)*);
       |    alias da_glVertexAttribP2ui = void function(GLuint, GLenum, GLboolean, GLuint);
       |    alias da_glVertexAttribP2uiv = void function(GLuint, GLenum, GLboolean, const(GLuint)*);
       |    alias da_glVertexAttribP3ui = void function(GLuint, GLenum, GLboolean, GLuint);
       |    alias da_glVertexAttribP3uiv = void function(GLuint, GLenum, GLboolean, const(GLuint)*);
       |    alias da_glVertexAttribP4ui = void function(GLuint, GLenum, GLboolean, GLuint);
       |    alias da_glVertexAttribP4uiv = void function(GLuint, GLenum, GLboolean, const(GLuint)*);
       |}
       |
       |__gshared {
       |    da_glVertexP2ui glVertexP2ui;
       |    da_glVertexP2uiv glVertexP2uiv;
       |    da_glVertexP3ui glVertexP3ui;
       |    da_glVertexP3uiv glVertexP3uiv;
       |    da_glVertexP4ui glVertexP4ui;
       |    da_glVertexP4uiv glVertexP4uiv;
       |    da_glTexCoordP1ui glTexCoordP1ui;
       |    da_glTexCoordP1uiv glTexCoordP1uiv;
       |    da_glTexCoordP2ui glTexCoordP2ui;
       |    da_glTexCoordP2uiv glTexCoordP2uiv;
       |    da_glTexCoordP3ui glTexCoordP3ui;
       |    da_glTexCoordP3uiv glTexCoordP3uiv;
       |    da_glTexCoordP4ui glTexCoordP4ui;
       |    da_glTexCoordP4uiv glTexCoordP4uiv;
       |    da_glMultiTexCoordP1ui glMultiTexCoordP1ui;
       |    da_glMultiTexCoordP1uiv glMultiTexCoordP1uiv;
       |    da_glMultiTexCoordP2ui glMultiTexCoordP2ui;
       |    da_glMultiTexCoordP2uiv glMultiTexCoordP2uiv;
       |    da_glMultiTexCoordP3ui glMultiTexCoordP3ui;
       |    da_glMultiTexCoordP3uiv glMultiTexCoordP3uiv;
       |    da_glMultiTexCoordP4ui glMultiTexCoordP4ui;
       |    da_glMultiTexCoordP4uiv glMultiTexCoordP4uiv;
       |    da_glNormalP3ui glNormalP3ui;
       |    da_glNormalP3uiv glNormalP3uiv;
       |    da_glColorP3ui glColorP3ui;
       |    da_glColorP3uiv glColorP3uiv;
       |    da_glColorP4ui glColorP4ui;
       |    da_glColorP4uiv glColorP4uiv;
       |    da_glSecondaryColorP3ui glSecondaryColorP3ui;
       |    da_glSecondaryColorP3uiv glSecondaryColorP3uiv;
       |    da_glVertexAttribP1ui glVertexAttribP1ui;
       |    da_glVertexAttribP1uiv glVertexAttribP1uiv;
       |    da_glVertexAttribP2ui glVertexAttribP2ui;
       |    da_glVertexAttribP2uiv glVertexAttribP2uiv;
       |    da_glVertexAttribP3ui glVertexAttribP3ui;
       |    da_glVertexAttribP3uiv glVertexAttribP3uiv;
       |    da_glVertexAttribP4ui glVertexAttribP4ui;
       |    da_glVertexAttribP4uiv glVertexAttribP4uiv;
       |}
       |
       |private __gshared bool _ARB_vertex_type_2_10_10_10_rev;
0000000|@nogc bool ARB_vertex_type_2_10_10_10_rev() nothrow @property { return _ARB_vertex_type_2_10_10_10_rev; }
       |package void load_ARB_vertex_type_2_10_10_10_rev(bool doThrow = false) {
       |    try {
       |        static if(!Derelict_OS_Mac) {
0000000|            bindGLFunc(cast(void**)&glVertexP2ui, "glVertexP2ui");
0000000|            bindGLFunc(cast(void**)&glVertexP2uiv, "glVertexP2uiv");
0000000|            bindGLFunc(cast(void**)&glVertexP3ui, "glVertexP3ui");
0000000|            bindGLFunc(cast(void**)&glVertexP3uiv, "glVertexP3uiv");
0000000|            bindGLFunc(cast(void**)&glVertexP4ui, "glVertexP4ui");
0000000|            bindGLFunc(cast(void**)&glVertexP4uiv, "glVertexP4uiv");
0000000|            bindGLFunc(cast(void**)&glTexCoordP1ui, "glTexCoordP1ui");
0000000|            bindGLFunc(cast(void**)&glTexCoordP1uiv, "glTexCoordP1uiv");
0000000|            bindGLFunc(cast(void**)&glTexCoordP2ui, "glTexCoordP2ui");
0000000|            bindGLFunc(cast(void**)&glTexCoordP2uiv, "glTexCoordP2uiv");
0000000|            bindGLFunc(cast(void**)&glTexCoordP3ui, "glTexCoordP3ui");
0000000|            bindGLFunc(cast(void**)&glTexCoordP3uiv, "glTexCoordP3uiv");
0000000|            bindGLFunc(cast(void**)&glTexCoordP4ui, "glTexCoordP4ui");
0000000|            bindGLFunc(cast(void**)&glTexCoordP4uiv, "glTexCoordP4uiv");
0000000|            bindGLFunc(cast(void**)&glMultiTexCoordP1ui, "glMultiTexCoordP1ui");
0000000|            bindGLFunc(cast(void**)&glMultiTexCoordP1uiv, "glMultiTexCoordP1uiv");
0000000|            bindGLFunc(cast(void**)&glMultiTexCoordP2ui, "glMultiTexCoordP2ui");
0000000|            bindGLFunc(cast(void**)&glMultiTexCoordP2uiv, "glMultiTexCoordP2uiv");
0000000|            bindGLFunc(cast(void**)&glMultiTexCoordP3ui, "glMultiTexCoordP3ui");
0000000|            bindGLFunc(cast(void**)&glMultiTexCoordP3uiv, "glMultiTexCoordP3uiv");
0000000|            bindGLFunc(cast(void**)&glMultiTexCoordP4ui, "glMultiTexCoordP4ui");
0000000|            bindGLFunc(cast(void**)&glMultiTexCoordP4uiv, "glMultiTexCoordP4uiv");
0000000|            bindGLFunc(cast(void**)&glNormalP3ui, "glNormalP3ui");
0000000|            bindGLFunc(cast(void**)&glNormalP3uiv, "glNormalP3uiv");
0000000|            bindGLFunc(cast(void**)&glColorP3ui, "glColorP3ui");
0000000|            bindGLFunc(cast(void**)&glColorP3uiv, "glColorP3uiv");
0000000|            bindGLFunc(cast(void**)&glColorP4ui, "glColorP4ui");
0000000|            bindGLFunc(cast(void**)&glColorP4uiv, "glColorP4uiv");
0000000|            bindGLFunc(cast(void**)&glSecondaryColorP3ui, "glSecondaryColorP3ui");
0000000|            bindGLFunc(cast(void**)&glSecondaryColorP3uiv, "glSecondaryColorP3uiv");
       |        }
0000000|        bindGLFunc(cast(void**)&glVertexAttribP1ui, "glVertexAttribP1ui");
0000000|        bindGLFunc(cast(void**)&glVertexAttribP1uiv, "glVertexAttribP1uiv");
0000000|        bindGLFunc(cast(void**)&glVertexAttribP2ui, "glVertexAttribP2ui");
0000000|        bindGLFunc(cast(void**)&glVertexAttribP2uiv, "glVertexAttribP2uiv");
0000000|        bindGLFunc(cast(void**)&glVertexAttribP3ui, "glVertexAttribP3ui");
0000000|        bindGLFunc(cast(void**)&glVertexAttribP3uiv, "glVertexAttribP3uiv");
0000000|        bindGLFunc(cast(void**)&glVertexAttribP4ui, "glVertexAttribP4ui");
0000000|        bindGLFunc(cast(void**)&glVertexAttribP4uiv, "glVertexAttribP4uiv");
0000000|        _ARB_vertex_type_2_10_10_10_rev = true;
       |    } catch(Exception e) {
0000000|        _ARB_vertex_type_2_10_10_10_rev = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_draw_indirect
       |extern(System) @nogc nothrow {
       |    alias da_glDrawArraysIndirect = void function(GLenum, const(GLvoid)*);
       |    alias da_glDrawElementsIndirect = void function(GLenum, GLenum, const(GLvoid)*);
       |}
       |
       |__gshared {
       |    da_glDrawArraysIndirect glDrawArraysIndirect;
       |    da_glDrawElementsIndirect glDrawElementsIndirect;
       |}
       |
       |private __gshared bool _ARB_draw_indirect;
0000000|@nogc bool ARB_draw_indirect() nothrow @property { return _ARB_draw_indirect; }
       |package void load_ARB_draw_indirect(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glDrawArraysIndirect, "glDrawArraysIndirect");
0000000|        bindGLFunc(cast(void**)&glDrawElementsIndirect, "glDrawElementsIndirect");
0000000|        _ARB_draw_indirect = true;
       |    } catch(Exception e) {
0000000|        _ARB_draw_indirect = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_gpu_shader_fp64
       |extern(System) @nogc nothrow {
       |    alias da_glUniform1d = void function(GLint, GLdouble);
       |    alias da_glUniform2d = void function(GLint, GLdouble, GLdouble);
       |    alias da_glUniform3d = void function(GLint, GLdouble, GLdouble, GLdouble);
       |    alias da_glUniform4d = void function(GLint, GLdouble, GLdouble, GLdouble, GLdouble);
       |    alias da_glUniform1dv = void function(GLint, GLsizei, const(GLdouble)*);
       |    alias da_glUniform2dv = void function(GLint, GLsizei, const(GLdouble)*);
       |    alias da_glUniform3dv = void function(GLint, GLsizei, const(GLdouble)*);
       |    alias da_glUniform4dv = void function(GLint, GLsizei, const(GLdouble)*);
       |    alias da_glUniformMatrix2dv = void function(GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glUniformMatrix3dv = void function(GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glUniformMatrix4dv = void function(GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glUniformMatrix2x3dv = void function(GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glUniformMatrix2x4dv = void function(GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glUniformMatrix3x2dv = void function(GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glUniformMatrix3x4dv = void function(GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glUniformMatrix4x2dv = void function(GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glUniformMatrix4x3dv = void function(GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glGetUniformdv = void function(GLuint, GLint, GLdouble*);
       |}
       |
       |__gshared {
       |    da_glUniform1d glUniform1d;
       |    da_glUniform2d glUniform2d;
       |    da_glUniform3d glUniform3d;
       |    da_glUniform4d glUniform4d;
       |    da_glUniform1dv glUniform1dv;
       |    da_glUniform2dv glUniform2dv;
       |    da_glUniform3dv glUniform3dv;
       |    da_glUniform4dv glUniform4dv;
       |    da_glUniformMatrix2dv glUniformMatrix2dv;
       |    da_glUniformMatrix3dv glUniformMatrix3dv;
       |    da_glUniformMatrix4dv glUniformMatrix4dv;
       |    da_glUniformMatrix2x3dv glUniformMatrix2x3dv;
       |    da_glUniformMatrix2x4dv glUniformMatrix2x4dv;
       |    da_glUniformMatrix3x2dv glUniformMatrix3x2dv;
       |    da_glUniformMatrix3x4dv glUniformMatrix3x4dv;
       |    da_glUniformMatrix4x2dv glUniformMatrix4x2dv;
       |    da_glUniformMatrix4x3dv glUniformMatrix4x3dv;
       |    da_glGetUniformdv glGetUniformdv;
       |}
       |
       |private __gshared bool _ARB_gpu_shader_fp64;
0000000|@nogc bool ARB_gpu_shader_fp64() nothrow @property { return _ARB_gpu_shader_fp64; }
       |package void load_ARB_gpu_shader_fp64(bool doThrow = false) {
       |    try
       |    {
0000000|        bindGLFunc(cast(void**)&glUniform1d, "glUniform1d");
0000000|        bindGLFunc(cast(void**)&glUniform2d, "glUniform2d");
0000000|        bindGLFunc(cast(void**)&glUniform3d, "glUniform3d");
0000000|        bindGLFunc(cast(void**)&glUniform4d, "glUniform4d");
0000000|        bindGLFunc(cast(void**)&glUniform1dv, "glUniform1dv");
0000000|        bindGLFunc(cast(void**)&glUniform2dv, "glUniform2dv");
0000000|        bindGLFunc(cast(void**)&glUniform3dv, "glUniform3dv");
0000000|        bindGLFunc(cast(void**)&glUniform4dv, "glUniform4dv");
0000000|        bindGLFunc(cast(void**)&glUniformMatrix2dv, "glUniformMatrix2dv");
0000000|        bindGLFunc(cast(void**)&glUniformMatrix3dv, "glUniformMatrix3dv");
0000000|        bindGLFunc(cast(void**)&glUniformMatrix4dv, "glUniformMatrix4dv");
0000000|        bindGLFunc(cast(void**)&glUniformMatrix2x3dv, "glUniformMatrix2x3dv");
0000000|        bindGLFunc(cast(void**)&glUniformMatrix2x4dv, "glUniformMatrix2x4dv");
0000000|        bindGLFunc(cast(void**)&glUniformMatrix3x2dv, "glUniformMatrix3x2dv");
0000000|        bindGLFunc(cast(void**)&glUniformMatrix3x4dv, "glUniformMatrix3x4dv");
0000000|        bindGLFunc(cast(void**)&glUniformMatrix4x2dv, "glUniformMatrix4x2dv");
0000000|        bindGLFunc(cast(void**)&glUniformMatrix4x3dv, "glUniformMatrix4x3dv");
0000000|        _ARB_gpu_shader_fp64 = true;
       |    } catch(Exception e) {
0000000|        _ARB_gpu_shader_fp64 = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_shader_subroutine
       |extern(System) @nogc nothrow {
       |    alias da_glGetSubroutineUniformLocation = GLint function(GLuint, GLenum, const(GLchar)*);
       |    alias da_glGetSubroutineIndex = GLuint function(GLuint, GLenum, const(GLchar)*);
       |    alias da_glGetActiveSubroutineUniformiv = void function(GLuint, GLenum, GLuint, GLenum, GLint*);
       |    alias da_glGetActiveSubroutineUniformName = void function(GLuint, GLenum, GLuint, GLsizei, GLsizei*, GLchar*);
       |    alias da_glGetActiveSubroutineName = void function(GLuint, GLenum, GLuint, GLsizei, GLsizei*, GLchar*);
       |    alias da_glUniformSubroutinesuiv = void function(GLenum, GLsizei, const(GLuint)*);
       |    alias da_glGetUniformSubroutineuiv = void function(GLenum, GLint, GLuint*);
       |    alias da_glGetProgramStageiv = void function(GLuint, GLenum, GLenum, GLint*);
       |}
       |
       |__gshared {
       |    da_glGetSubroutineUniformLocation glGetSubroutineUniformLocation;
       |    da_glGetSubroutineIndex glGetSubroutineIndex;
       |    da_glGetActiveSubroutineUniformiv glGetActiveSubroutineUniformiv;
       |    da_glGetActiveSubroutineUniformName glGetActiveSubroutineUniformName;
       |    da_glGetActiveSubroutineName glGetActiveSubroutineName;
       |    da_glUniformSubroutinesuiv glUniformSubroutinesuiv;
       |    da_glGetUniformSubroutineuiv glGetUniformSubroutineuiv;
       |    da_glGetProgramStageiv glGetProgramStageiv;
       |}
       |
       |private __gshared bool _ARB_shader_subroutine;
0000000|@nogc bool ARB_shader_subroutine() nothrow @property { return _ARB_shader_subroutine; }
       |package void load_ARB_shader_subroutine(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glGetSubroutineUniformLocation, "glGetSubroutineUniformLocation");
0000000|        bindGLFunc(cast(void**)&glGetSubroutineIndex, "glGetSubroutineIndex");
0000000|        bindGLFunc(cast(void**)&glGetActiveSubroutineUniformiv, "glGetActiveSubroutineUniformiv");
0000000|        bindGLFunc(cast(void**)&glGetActiveSubroutineUniformName, "glGetActiveSubroutineUniformName");
0000000|        bindGLFunc(cast(void**)&glGetActiveSubroutineName, "glGetActiveSubroutineName");
0000000|        bindGLFunc(cast(void**)&glUniformSubroutinesuiv, "glUniformSubroutinesuiv");
0000000|        bindGLFunc(cast(void**)&glGetUniformSubroutineuiv, "glGetUniformSubroutineuiv");
0000000|        bindGLFunc(cast(void**)&glGetProgramStageiv, "glGetProgramStageiv");
0000000|        _ARB_shader_subroutine = true;
       |    } catch(Exception e) {
0000000|        _ARB_shader_subroutine = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_tessellation_shader
       |extern(System) @nogc nothrow {
       |    alias da_glPatchParameteri = void function(GLenum, GLint);
       |    alias da_glPatchParameterfv = void function(GLenum, const(GLfloat)*);
       |}
       |__gshared da_glPatchParameteri glPatchParameteri;
       |__gshared da_glPatchParameterfv glPatchParameterfv;
       |
       |private __gshared bool _ARB_tessellation_shader;
0000000|@nogc bool ARB_tessellation_shader() nothrow @property { return _ARB_tessellation_shader; }
       |package void load_ARB_tessellation_shader(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glPatchParameteri, "glPatchParameteri");
0000000|        bindGLFunc(cast(void**)&glPatchParameterfv, "glPatchParameterfv");
0000000|        _ARB_tessellation_shader = true;
       |    } catch(Exception e) {
0000000|        _ARB_tessellation_shader = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_transform_feedback2
       |extern(System) @nogc nothrow {
       |    alias da_glBindTransformFeedback = void function(GLenum, GLuint);
       |    alias da_glDeleteTransformFeedbacks = void function(GLsizei, const(GLuint)*);
       |    alias da_glGenTransformFeedbacks = void function(GLsizei, GLuint*);
       |    alias da_glIsTransformFeedback = GLboolean function(GLuint);
       |    alias da_glPauseTransformFeedback = void function();
       |    alias da_glResumeTransformFeedback = void function();
       |    alias da_glDrawTransformFeedback = void function(GLenum, GLuint);
       |}
       |
       |__gshared {
       |    da_glBindTransformFeedback glBindTransformFeedback;
       |    da_glDeleteTransformFeedbacks glDeleteTransformFeedbacks;
       |    da_glGenTransformFeedbacks glGenTransformFeedbacks;
       |    da_glIsTransformFeedback glIsTransformFeedback;
       |    da_glPauseTransformFeedback glPauseTransformFeedback;
       |    da_glResumeTransformFeedback glResumeTransformFeedback;
       |    da_glDrawTransformFeedback glDrawTransformFeedback;
       |}
       |
       |private __gshared bool _ARB_transform_feedback2;
0000000|@nogc bool ARB_transform_feedback2() { return _ARB_transform_feedback2; }
       |void load_ARB_transform_feedback2(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glBindTransformFeedback, "glBindTransformFeedback");
0000000|        bindGLFunc(cast(void**)&glDeleteTransformFeedbacks, "glDeleteTransformFeedbacks");
0000000|        bindGLFunc(cast(void**)&glGenTransformFeedbacks, "glGenTransformFeedbacks");
0000000|        bindGLFunc(cast(void**)&glIsTransformFeedback, "glIsTransformFeedback");
0000000|        bindGLFunc(cast(void**)&glPauseTransformFeedback, "glPauseTransformFeedback");
0000000|        bindGLFunc(cast(void**)&glResumeTransformFeedback, "glResumeTransformFeedback");
0000000|        bindGLFunc(cast(void**)&glDrawTransformFeedback, "glDrawTransformFeedback");
0000000|        _ARB_transform_feedback2 = true;
       |    } catch(Exception e) {
0000000|        _ARB_transform_feedback2 = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_transform_feedback3
       |extern(System) @nogc nothrow {
       |    alias da_glDrawTransformFeedbackStream = void function(GLenum, GLuint, GLuint);
       |    alias da_glBeginQueryIndexed = void function(GLenum, GLuint, GLuint);
       |    alias da_glEndQueryIndexed = void function(GLenum, GLuint);
       |    alias da_glGetQueryIndexediv = void function(GLenum, GLuint, GLenum, GLint*);
       |}
       |
       |__gshared {
       |    da_glDrawTransformFeedbackStream glDrawTransformFeedbackStream;
       |    da_glBeginQueryIndexed glBeginQueryIndexed;
       |    da_glEndQueryIndexed glEndQueryIndexed;
       |    da_glGetQueryIndexediv glGetQueryIndexediv;
       |}
       |
       |private __gshared bool _ARB_transform_feedback3;
0000000|@nogc bool ARB_transform_feedback3() { return _ARB_transform_feedback3; }
       |package void load_ARB_transform_feedback3(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glDrawTransformFeedbackStream, "glDrawTransformFeedbackStream");
0000000|        bindGLFunc(cast(void**)&glBeginQueryIndexed, "glBeginQueryIndexed");
0000000|        bindGLFunc(cast(void**)&glEndQueryIndexed, "glEndQueryIndexed");
0000000|        bindGLFunc(cast(void**)&glGetQueryIndexediv, "glGetQueryIndexediv");
0000000|        _ARB_transform_feedback3 = true;
       |    } catch(Exception e) {
0000000|        _ARB_transform_feedback3 = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_ES2_compatibility
       |extern(System) @nogc nothrow {
       |    alias da_glReleaseShaderCompiler = void function();
       |    alias da_glShaderBinary = void function(GLsizei, const(GLuint)*, GLenum, const(GLvoid)*, GLsizei);
       |    alias da_glGetShaderPrecisionFormat = void function(GLenum, GLenum, GLint*, GLint*);
       |    alias da_glDepthRangef = void function(GLclampf, GLclampf);
       |    alias da_glClearDepthf = void function(GLclampf);
       |}
       |
       |__gshared {
       |    da_glReleaseShaderCompiler glReleaseShaderCompiler;
       |    da_glShaderBinary glShaderBinary;
       |    da_glGetShaderPrecisionFormat glGetShaderPrecisionFormat;
       |    da_glDepthRangef glDepthRangef;
       |    da_glClearDepthf glClearDepthf;
       |}
       |
       |private __gshared bool _ARB_ES2_compatibility;
0000000|@nogc bool ARB_ES2_compatibility() nothrow @property { return _ARB_ES2_compatibility; }
       |package void load_ARB_ES2_compatibility(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glReleaseShaderCompiler, "glReleaseShaderCompiler");
0000000|        bindGLFunc(cast(void**)&glShaderBinary, "glShaderBinary");
0000000|        bindGLFunc(cast(void**)&glGetShaderPrecisionFormat, "glGetShaderPrecisionFormat");
0000000|        bindGLFunc(cast(void**)&glDepthRangef, "glDepthRangef");
0000000|        bindGLFunc(cast(void**)&glClearDepthf, "glClearDepthf");
0000000|        _ARB_ES2_compatibility = true;
       |    } catch(Exception e) {
0000000|        _ARB_ES2_compatibility = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_get_program_binary
       |extern(System) @nogc nothrow {
       |    alias da_glGetProgramBinary = void function(GLuint, GLsizei, GLsizei*, GLenum*, GLvoid*);
       |    alias da_glProgramBinary = void function(GLuint, GLenum, const(GLvoid)*, GLsizei);
       |    alias da_glProgramParameteri = void function(GLuint, GLenum, GLint);
       |}
       |
       |__gshared {
       |    da_glGetProgramBinary glGetProgramBinary;
       |    da_glProgramBinary glProgramBinary;
       |    da_glProgramParameteri glProgramParameteri;
       |}
       |
       |private __gshared bool _ARB_get_program_binary;
0000000|@nogc bool ARB_get_program_binary() nothrow @property { return _ARB_get_program_binary; }
       |package void load_ARB_get_program_binary(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glGetProgramBinary, "glGetProgramBinary");
0000000|        bindGLFunc(cast(void**)&glProgramBinary, "glProgramBinary");
0000000|        bindGLFunc(cast(void**)&glProgramParameteri, "glProgramParameteri");
0000000|        _ARB_get_program_binary = true;
       |    } catch(Exception e) {
0000000|        _ARB_get_program_binary = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_separate_shader_objects
       |extern(System) @nogc nothrow {
       |    alias da_glUseProgramStages = void function(GLuint, GLbitfield, GLuint);
       |    alias da_glActiveShaderProgram = void function(GLuint, GLuint);
       |    alias da_glCreateShaderProgramv = GLuint function(GLenum, GLsizei, const(GLchar*)*);
       |    alias da_glBindProgramPipeline = void function(GLuint);
       |    alias da_glDeleteProgramPipelines = void function(GLsizei, const(GLuint)*);
       |    alias da_glGenProgramPipelines = void function(GLsizei, GLuint*);
       |    alias da_glIsProgramPipeline = GLboolean function(GLuint);
       |    alias da_glGetProgramPipelineiv = void function(GLuint, GLenum, GLint*);
       |    alias da_glProgramUniform1i = void function(GLuint, GLint, GLint);
       |    alias da_glProgramUniform1iv = void function(GLuint, GLint, GLsizei, const(GLint)*);
       |    alias da_glProgramUniform1f = void function(GLuint, GLint, GLfloat);
       |    alias da_glProgramUniform1fv = void function(GLuint, GLint, GLsizei, const(GLfloat)*);
       |    alias da_glProgramUniform1d = void function(GLuint, GLint, GLdouble);
       |    alias da_glProgramUniform1dv = void function(GLuint, GLint, GLsizei, const(GLdouble)*);
       |    alias da_glProgramUniform1ui = void function(GLuint, GLint, GLuint);
       |    alias da_glProgramUniform1uiv = void function(GLuint, GLint, GLsizei, const(GLuint)*);
       |    alias da_glProgramUniform2i = void function(GLuint, GLint, GLint, GLint);
       |    alias da_glProgramUniform2iv = void function(GLuint, GLint, GLsizei, const(GLint)*);
       |    alias da_glProgramUniform2f = void function(GLuint, GLint, GLfloat, GLfloat);
       |    alias da_glProgramUniform2fv = void function(GLuint, GLint, GLsizei, const(GLfloat)*);
       |    alias da_glProgramUniform2d = void function(GLuint, GLint, GLdouble, GLdouble);
       |    alias da_glProgramUniform2dv = void function(GLuint, GLint, GLsizei, const(GLdouble)*);
       |    alias da_glProgramUniform2ui = void function(GLuint, GLint, GLuint, GLuint);
       |    alias da_glProgramUniform2uiv = void function(GLuint, GLint, GLsizei, const(GLuint)*);
       |    alias da_glProgramUniform3i = void function(GLuint, GLint, GLint, GLint, GLint);
       |    alias da_glProgramUniform3iv = void function(GLuint, GLint, GLsizei, const(GLint)*);
       |    alias da_glProgramUniform3f = void function(GLuint, GLint, GLfloat, GLfloat, GLfloat);
       |    alias da_glProgramUniform3fv = void function(GLuint, GLint, GLsizei, const(GLfloat)*);
       |    alias da_glProgramUniform3d = void function(GLuint, GLint, GLdouble, GLdouble, GLdouble);
       |    alias da_glProgramUniform3dv = void function(GLuint, GLint, GLsizei, const(GLdouble)*);
       |    alias da_glProgramUniform3ui = void function(GLuint, GLint, GLuint, GLuint, GLuint);
       |    alias da_glProgramUniform3uiv = void function(GLuint, GLint, GLsizei, const(GLuint)*);
       |    alias da_glProgramUniform4i = void function(GLuint, GLint, GLint, GLint, GLint, GLint);
       |    alias da_glProgramUniform4iv = void function(GLuint, GLint, GLsizei, const(GLint)*);
       |    alias da_glProgramUniform4f = void function(GLuint, GLint, GLfloat, GLfloat, GLfloat, GLfloat);
       |    alias da_glProgramUniform4fv = void function(GLuint, GLint, GLsizei, const(GLfloat)*);
       |    alias da_glProgramUniform4d = void function(GLuint, GLint, GLdouble, GLdouble, GLdouble, GLdouble);
       |    alias da_glProgramUniform4dv = void function(GLuint, GLint, GLsizei, const(GLdouble)*);
       |    alias da_glProgramUniform4ui = void function(GLuint, GLint, GLuint, GLuint, GLuint, GLuint);
       |    alias da_glProgramUniform4uiv = void function(GLuint, GLint, GLsizei, const(GLuint)*);
       |    alias da_glProgramUniformMatrix2fv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*);
       |    alias da_glProgramUniformMatrix3fv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*);
       |    alias da_glProgramUniformMatrix4fv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*);
       |    alias da_glProgramUniformMatrix2dv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glProgramUniformMatrix3dv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glProgramUniformMatrix4dv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glProgramUniformMatrix2x3fv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*);
       |    alias da_glProgramUniformMatrix3x2fv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*);
       |    alias da_glProgramUniformMatrix2x4fv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*);
       |    alias da_glProgramUniformMatrix4x2fv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*);
       |    alias da_glProgramUniformMatrix3x4fv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*);
       |    alias da_glProgramUniformMatrix4x3fv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLfloat)*);
       |    alias da_glProgramUniformMatrix2x3dv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glProgramUniformMatrix3x2dv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glProgramUniformMatrix2x4dv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glProgramUniformMatrix4x2dv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glProgramUniformMatrix3x4dv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glProgramUniformMatrix4x3dv = void function(GLuint, GLint, GLsizei, GLboolean, const(GLdouble)*);
       |    alias da_glValidateProgramPipeline = void function(GLuint);
       |    alias da_glGetProgramPipelineInfoLog = void function(GLuint, GLsizei, GLsizei*, GLchar*);
       |}
       |
       |__gshared {
       |    da_glUseProgramStages glUseProgramStages;
       |    da_glActiveShaderProgram glActiveShaderProgram;
       |    da_glCreateShaderProgramv glCreateShaderProgramv;
       |    da_glBindProgramPipeline glBindProgramPipeline;
       |    da_glDeleteProgramPipelines glDeleteProgramPipelines;
       |    da_glGenProgramPipelines glGenProgramPipelines;
       |    da_glIsProgramPipeline glIsProgramPipeline;
       |    da_glGetProgramPipelineiv glGetProgramPipelineiv;
       |    da_glProgramUniform1i glProgramUniform1i;
       |    da_glProgramUniform1iv glProgramUniform1iv;
       |    da_glProgramUniform1f glProgramUniform1f;
       |    da_glProgramUniform1fv glProgramUniform1fv;
       |    da_glProgramUniform1d glProgramUniform1d;
       |    da_glProgramUniform1dv glProgramUniform1dv;
       |    da_glProgramUniform1ui glProgramUniform1ui;
       |    da_glProgramUniform1uiv glProgramUniform1uiv;
       |    da_glProgramUniform2i glProgramUniform2i;
       |    da_glProgramUniform2iv glProgramUniform2iv;
       |    da_glProgramUniform2f glProgramUniform2f;
       |    da_glProgramUniform2fv glProgramUniform2fv;
       |    da_glProgramUniform2d glProgramUniform2d;
       |    da_glProgramUniform2dv glProgramUniform2dv;
       |    da_glProgramUniform2ui glProgramUniform2ui;
       |    da_glProgramUniform2uiv glProgramUniform2uiv;
       |    da_glProgramUniform3i glProgramUniform3i;
       |    da_glProgramUniform3iv glProgramUniform3iv;
       |    da_glProgramUniform3f glProgramUniform3f;
       |    da_glProgramUniform3fv glProgramUniform3fv;
       |    da_glProgramUniform3d glProgramUniform3d;
       |    da_glProgramUniform3dv glProgramUniform3dv;
       |    da_glProgramUniform3ui glProgramUniform3ui;
       |    da_glProgramUniform3uiv glProgramUniform3uiv;
       |    da_glProgramUniform4i glProgramUniform4i;
       |    da_glProgramUniform4iv glProgramUniform4iv;
       |    da_glProgramUniform4f glProgramUniform4f;
       |    da_glProgramUniform4fv glProgramUniform4fv;
       |    da_glProgramUniform4d glProgramUniform4d;
       |    da_glProgramUniform4dv glProgramUniform4dv;
       |    da_glProgramUniform4ui glProgramUniform4ui;
       |    da_glProgramUniform4uiv glProgramUniform4uiv;
       |    da_glProgramUniformMatrix2fv glProgramUniformMatrix2fv;
       |    da_glProgramUniformMatrix3fv glProgramUniformMatrix3fv;
       |    da_glProgramUniformMatrix4fv glProgramUniformMatrix4fv;
       |    da_glProgramUniformMatrix2dv glProgramUniformMatrix2dv;
       |    da_glProgramUniformMatrix3dv glProgramUniformMatrix3dv;
       |    da_glProgramUniformMatrix4dv glProgramUniformMatrix4dv;
       |    da_glProgramUniformMatrix2x3fv glProgramUniformMatrix2x3fv;
       |    da_glProgramUniformMatrix3x2fv glProgramUniformMatrix3x2fv;
       |    da_glProgramUniformMatrix2x4fv glProgramUniformMatrix2x4fv;
       |    da_glProgramUniformMatrix4x2fv glProgramUniformMatrix4x2fv;
       |    da_glProgramUniformMatrix3x4fv glProgramUniformMatrix3x4fv;
       |    da_glProgramUniformMatrix4x3fv glProgramUniformMatrix4x3fv;
       |    da_glProgramUniformMatrix2x3dv glProgramUniformMatrix2x3dv;
       |    da_glProgramUniformMatrix3x2dv glProgramUniformMatrix3x2dv;
       |    da_glProgramUniformMatrix2x4dv glProgramUniformMatrix2x4dv;
       |    da_glProgramUniformMatrix4x2dv glProgramUniformMatrix4x2dv;
       |    da_glProgramUniformMatrix3x4dv glProgramUniformMatrix3x4dv;
       |    da_glProgramUniformMatrix4x3dv glProgramUniformMatrix4x3dv;
       |    da_glValidateProgramPipeline glValidateProgramPipeline;
       |    da_glGetProgramPipelineInfoLog glGetProgramPipelineInfoLog;
       |}
       |
       |private __gshared bool _ARB_separate_shader_objects;
0000000|@nogc bool ARB_separate_shader_objects() nothrow @property { return _ARB_separate_shader_objects; }
       |package void load_ARB_separate_shader_objects(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glUseProgramStages, "glUseProgramStages");
0000000|        bindGLFunc(cast(void**)&glActiveShaderProgram, "glActiveShaderProgram");
0000000|        bindGLFunc(cast(void**)&glCreateShaderProgramv, "glCreateShaderProgramv");
0000000|        bindGLFunc(cast(void**)&glBindProgramPipeline, "glBindProgramPipeline");
0000000|        bindGLFunc(cast(void**)&glDeleteProgramPipelines, "glDeleteProgramPipelines");
0000000|        bindGLFunc(cast(void**)&glGenProgramPipelines, "glGenProgramPipelines");
0000000|        bindGLFunc(cast(void**)&glIsProgramPipeline, "glIsProgramPipeline");
0000000|        bindGLFunc(cast(void**)&glGetProgramPipelineiv, "glGetProgramPipelineiv");
0000000|        bindGLFunc(cast(void**)&glProgramUniform1i, "glProgramUniform1i");
0000000|        bindGLFunc(cast(void**)&glProgramUniform1iv, "glProgramUniform1iv");
0000000|        bindGLFunc(cast(void**)&glProgramUniform1f, "glProgramUniform1f");
0000000|        bindGLFunc(cast(void**)&glProgramUniform1fv, "glProgramUniform1fv");
0000000|        bindGLFunc(cast(void**)&glProgramUniform1d, "glProgramUniform1d");
0000000|        bindGLFunc(cast(void**)&glProgramUniform1dv, "glProgramUniform1dv");
0000000|        bindGLFunc(cast(void**)&glProgramUniform1ui, "glProgramUniform1ui");
0000000|        bindGLFunc(cast(void**)&glProgramUniform1uiv, "glProgramUniform1uiv");
0000000|        bindGLFunc(cast(void**)&glProgramUniform2i, "glProgramUniform2i");
0000000|        bindGLFunc(cast(void**)&glProgramUniform2iv, "glProgramUniform2iv");
0000000|        bindGLFunc(cast(void**)&glProgramUniform2f, "glProgramUniform2f");
0000000|        bindGLFunc(cast(void**)&glProgramUniform2fv, "glProgramUniform2fv");
0000000|        bindGLFunc(cast(void**)&glProgramUniform2d, "glProgramUniform2d");
0000000|        bindGLFunc(cast(void**)&glProgramUniform2dv, "glProgramUniform2dv");
0000000|        bindGLFunc(cast(void**)&glProgramUniform2ui, "glProgramUniform2ui");
0000000|        bindGLFunc(cast(void**)&glProgramUniform2uiv, "glProgramUniform2uiv");
0000000|        bindGLFunc(cast(void**)&glProgramUniform3i, "glProgramUniform3i");
0000000|        bindGLFunc(cast(void**)&glProgramUniform3iv, "glProgramUniform3iv");
0000000|        bindGLFunc(cast(void**)&glProgramUniform3f, "glProgramUniform3f");
0000000|        bindGLFunc(cast(void**)&glProgramUniform3fv, "glProgramUniform3fv");
0000000|        bindGLFunc(cast(void**)&glProgramUniform3d, "glProgramUniform3d");
0000000|        bindGLFunc(cast(void**)&glProgramUniform3dv, "glProgramUniform3dv");
0000000|        bindGLFunc(cast(void**)&glProgramUniform3ui, "glProgramUniform3ui");
0000000|        bindGLFunc(cast(void**)&glProgramUniform3uiv, "glProgramUniform3uiv");
0000000|        bindGLFunc(cast(void**)&glProgramUniform4i, "glProgramUniform4i");
0000000|        bindGLFunc(cast(void**)&glProgramUniform4iv, "glProgramUniform4iv");
0000000|        bindGLFunc(cast(void**)&glProgramUniform4f, "glProgramUniform4f");
0000000|        bindGLFunc(cast(void**)&glProgramUniform4fv, "glProgramUniform4fv");
0000000|        bindGLFunc(cast(void**)&glProgramUniform4d, "glProgramUniform4d");
0000000|        bindGLFunc(cast(void**)&glProgramUniform4dv, "glProgramUniform4dv");
0000000|        bindGLFunc(cast(void**)&glProgramUniform4ui, "glProgramUniform4ui");
0000000|        bindGLFunc(cast(void**)&glProgramUniform4uiv, "glProgramUniform4uiv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix2fv, "glProgramUniformMatrix2fv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix3fv, "glProgramUniformMatrix3fv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix4fv, "glProgramUniformMatrix4fv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix2dv, "glProgramUniformMatrix2dv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix3dv, "glProgramUniformMatrix3dv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix4dv, "glProgramUniformMatrix4dv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix2x3fv, "glProgramUniformMatrix2x3fv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix3x2fv, "glProgramUniformMatrix3x2fv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix2x4fv, "glProgramUniformMatrix2x4fv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix4x2fv, "glProgramUniformMatrix4x2fv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix3x4fv, "glProgramUniformMatrix3x4fv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix4x3fv, "glProgramUniformMatrix4x3fv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix2x3dv, "glProgramUniformMatrix2x3dv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix3x2dv, "glProgramUniformMatrix3x2dv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix2x4dv, "glProgramUniformMatrix2x4dv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix4x2dv, "glProgramUniformMatrix4x2dv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix3x4dv, "glProgramUniformMatrix3x4dv");
0000000|        bindGLFunc(cast(void**)&glProgramUniformMatrix4x3dv, "glProgramUniformMatrix4x3dv");
0000000|        bindGLFunc(cast(void**)&glValidateProgramPipeline, "glValidateProgramPipeline");
0000000|        bindGLFunc(cast(void**)&glGetProgramPipelineInfoLog, "glGetProgramPipelineInfoLog");
0000000|        _ARB_separate_shader_objects = true;
       |    } catch(Exception e) {
0000000|        _ARB_separate_shader_objects = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_vertex_attrib_64bit
       |extern(System) @nogc nothrow {
       |    alias da_glVertexAttribL1d = void function(GLuint, GLdouble);
       |    alias da_glVertexAttribL2d = void function(GLuint, GLdouble, GLdouble);
       |    alias da_glVertexAttribL3d = void function(GLuint, GLdouble, GLdouble, GLdouble);
       |    alias da_glVertexAttribL4d = void function(GLuint, GLdouble, GLdouble, GLdouble, GLdouble);
       |    alias da_glVertexAttribL1dv = void function(GLuint, const(GLdouble)*);
       |    alias da_glVertexAttribL2dv = void function(GLuint, const(GLdouble)*);
       |    alias da_glVertexAttribL3dv = void function(GLuint, const(GLdouble)*);
       |    alias da_glVertexAttribL4dv = void function(GLuint, const(GLdouble)*);
       |    alias da_glVertexAttribLPointer = void function(GLuint, GLint, GLenum, GLsizei, const(GLvoid)*);
       |    alias da_glGetVertexAttribLdv = void function(GLuint, GLenum, GLdouble*);
       |}
       |
       |__gshared {
       |    da_glVertexAttribL1d glVertexAttribL1d;
       |    da_glVertexAttribL2d glVertexAttribL2d;
       |    da_glVertexAttribL3d glVertexAttribL3d;
       |    da_glVertexAttribL4d glVertexAttribL4d;
       |    da_glVertexAttribL1dv glVertexAttribL1dv;
       |    da_glVertexAttribL2dv glVertexAttribL2dv;
       |    da_glVertexAttribL3dv glVertexAttribL3dv;
       |    da_glVertexAttribL4dv glVertexAttribL4dv;
       |    da_glVertexAttribLPointer glVertexAttribLPointer;
       |    da_glGetVertexAttribLdv glGetVertexAttribLdv;
       |}
       |
       |private __gshared bool _ARB_vertex_attrib_64bit;
0000000|@nogc bool ARB_vertex_attrib_64bit() nothrow @property { return _ARB_vertex_attrib_64bit; }
       |package void load_ARB_vertex_attrib_64bit(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glVertexAttribL1d, "glVertexAttribL1d");
0000000|        bindGLFunc(cast(void**)&glVertexAttribL2d, "glVertexAttribL2d");
0000000|        bindGLFunc(cast(void**)&glVertexAttribL3d, "glVertexAttribL3d");
0000000|        bindGLFunc(cast(void**)&glVertexAttribL4d, "glVertexAttribL4d");
0000000|        bindGLFunc(cast(void**)&glVertexAttribL1dv, "glVertexAttribL1dv");
0000000|        bindGLFunc(cast(void**)&glVertexAttribL2dv, "glVertexAttribL2dv");
0000000|        bindGLFunc(cast(void**)&glVertexAttribL3dv, "glVertexAttribL3dv");
0000000|        bindGLFunc(cast(void**)&glVertexAttribL4dv, "glVertexAttribL4dv");
0000000|        bindGLFunc(cast(void**)&glVertexAttribLPointer, "glVertexAttribLPointer");
0000000|        bindGLFunc(cast(void**)&glGetVertexAttribLdv, "glGetVertexAttribLdv");
0000000|        _ARB_vertex_attrib_64bit = true;
       |    } catch(Exception e) {
0000000|        _ARB_vertex_attrib_64bit = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_viewport_array
       |extern(System) @nogc nothrow {
       |    alias da_glViewportArrayv = void function(GLuint, GLsizei, const(GLfloat)*);
       |    alias da_glViewportIndexedf = void function(GLuint, GLfloat, GLfloat, GLfloat, GLfloat);
       |    alias da_glViewportIndexedfv = void function(GLuint, const(GLfloat)*);
       |    alias da_glScissorArrayv = void function(GLuint, GLsizei, const(GLint)*);
       |    alias da_glScissorIndexed = void function(GLuint, GLint, GLint, GLsizei, GLsizei);
       |    alias da_glScissorIndexedv = void function(GLuint, const(GLint)*);
       |    alias da_glDepthRangeArrayv = void function(GLuint, GLsizei, const(GLclampd)*);
       |    alias da_glDepthRangeIndexed = void function(GLuint, GLclampd, GLclampd);
       |    alias da_glGetFloati_v = void function(GLenum, GLuint, GLfloat*);
       |    alias da_glGetDoublei_v = void function(GLenum, GLuint, GLdouble*);
       |}
       |
       |__gshared {
       |    da_glViewportArrayv glViewportArrayv;
       |    da_glViewportIndexedf glViewportIndexedf;
       |    da_glViewportIndexedfv glViewportIndexedfv;
       |    da_glScissorArrayv glScissorArrayv;
       |    da_glScissorIndexed glScissorIndexed;
       |    da_glScissorIndexedv glScissorIndexedv;
       |    da_glDepthRangeArrayv glDepthRangeArrayv;
       |    da_glDepthRangeIndexed glDepthRangeIndexed;
       |    da_glGetFloati_v glGetFloati_v;
       |    da_glGetDoublei_v glGetDoublei_v;
       |}
       |
       |private __gshared bool _ARB_viewport_array;
0000000|@nogc bool ARB_viewport_array() nothrow @property { return _ARB_viewport_array; }
       |package void load_ARB_viewport_array(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glViewportArrayv, "glViewportArrayv");
0000000|        bindGLFunc(cast(void**)&glViewportIndexedf, "glViewportIndexedf");
0000000|        bindGLFunc(cast(void**)&glViewportIndexedfv, "glViewportIndexedfv");
0000000|        bindGLFunc(cast(void**)&glScissorArrayv, "glScissorArrayv");
0000000|        bindGLFunc(cast(void**)&glScissorIndexed, "glScissorIndexed");
0000000|        bindGLFunc(cast(void**)&glScissorIndexedv, "glScissorIndexedv");
0000000|        bindGLFunc(cast(void**)&glDepthRangeArrayv, "glDepthRangeArrayv");
0000000|        bindGLFunc(cast(void**)&glDepthRangeIndexed, "glDepthRangeIndexed");
0000000|        bindGLFunc(cast(void**)&glGetFloati_v, "glGetFloati_v");
0000000|        bindGLFunc(cast(void**)&glGetDoublei_v, "glGetDoublei_v");
0000000|        _ARB_viewport_array = true;
       |    } catch(Exception e) {
0000000|        _ARB_viewport_array = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_cl_event
       |extern(System) @nogc nothrow alias  da_glCreateSyncFromCLeventARB = GLsync function(_cl_context*, _cl_event*, GLbitfield);
       |__gshared da_glCreateSyncFromCLeventARB glCreateSyncFromCLeventARB;
       |
       |private __gshared bool _ARB_cl_event;
0000000|@nogc bool ARB_cl_event() nothrow @property { return _ARB_cl_event; }
       |package void load_ARB_cl_event() {
       |    try {
0000000|        bindGLFunc(cast(void**)&glCreateSyncFromCLeventARB, "glCreateSyncFromCLeventARB");
0000000|        _ARB_cl_event = true;
       |    } catch(Exception e) {
0000000|        _ARB_cl_event = false;
       |    }
       |}
       |
       |// ARB_debug_output
       |extern(System) @nogc nothrow {
       |    alias da_glDebugMessageControlARB = void function(GLenum, GLenum, GLenum, GLsizei, const(GLuint)*, GLboolean);
       |    alias da_glDebugMessageInsertARB = void function(GLenum, GLenum, GLuint, GLenum, GLsizei, const(GLchar)*);
       |    alias da_glGetDebugMessageLogARB = void function(GLuint, GLsizei, GLenum*, GLenum*, GLuint*, GLenum*, GLsizei*, GLchar*);
       |    alias da_glDebugMessageCallbackARB = void function(GLDEBUGPROCARB, const(GLvoid)*);
       |}
       |
       |__gshared {
       |    da_glDebugMessageControlARB glDebugMessageControlARB;
       |    da_glDebugMessageInsertARB glDebugMessageInsertARB;
       |    da_glDebugMessageCallbackARB glDebugMessageCallbackARB;
       |    da_glGetDebugMessageLogARB glGetDebugMessageLogARB;
       |}
       |
       |private __gshared bool _ARB_debug_output;
0000000|@nogc bool ARB_debug_output() nothrow @property { return _ARB_debug_output; }
       |package void load_ARB_debug_output() {
       |    try {
0000000|        bindGLFunc(cast(void**)&glDebugMessageControlARB, "glDebugMessageControlARB");
0000000|        bindGLFunc(cast(void**)&glDebugMessageInsertARB, "glDebugMessageInsertARB");
0000000|        bindGLFunc(cast(void**)&glDebugMessageCallbackARB, "glDebugMessageCallbackARB");
0000000|        bindGLFunc(cast(void**)&glGetDebugMessageLogARB, "glGetDebugMessageLogARB");
0000000|        _ARB_debug_output = true;
       |    } catch(Exception e) {
0000000|        _ARB_debug_output = false;
       |    }
       |}
       |
       |// ARB_robustness
       |extern(System) @nogc nothrow {
       |    alias da_glGetGraphicsResetStatusARB = GLenum function();
       |    alias da_glGetnMapdvARB = void function(GLenum, GLenum, GLsizei, GLdouble*);
       |    alias da_glGetnMapfvARB = void function(GLenum, GLenum, GLsizei, GLfloat*);
       |    alias da_glGetnMapivARB = void function(GLenum, GLenum, GLsizei, GLint*);
       |    alias da_glGetnPixelMapfvARB = void function(GLenum, GLsizei, GLfloat*);
       |    alias da_glGetnPixelMapuivARB = void function(GLenum, GLsizei, GLuint*);
       |    alias da_glGetnPixelMapusvARB = void function(GLenum, GLsizei, GLushort*);
       |    alias da_glGetnPolygonStippleARB = void function(GLsizei, GLubyte*);
       |    alias da_glGetnColorTableARB = void function(GLenum, GLenum, GLenum, GLsizei, GLvoid*);
       |    alias da_glGetnConvolutionFilterARB = void function(GLenum, GLenum, GLenum, GLsizei, GLvoid*);
       |    alias da_glGetnSeparableFilterARB = void function(GLenum, GLenum, GLenum, GLsizei, GLvoid*, GLsizei, GLvoid*, GLvoid*);
       |    alias da_glGetnHistogramARB = void function(GLenum, GLboolean, GLenum, GLenum, GLsizei, GLvoid*);
       |    alias da_glGetnMinmaxARB = void function(GLenum, GLboolean, GLenum, GLenum, GLsizei, GLvoid*);
       |    alias da_glGetnTexImageARB = void function(GLenum, GLint, GLenum, GLenum, GLsizei, GLvoid*);
       |    alias da_glReadnPixelsARB = void function(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLsizei, GLvoid*);
       |    alias da_glGetnCompressedTexImageARB = void function(GLenum, GLint, GLsizei, GLvoid*);
       |    alias da_glGetnUniformfvARB = void function(GLuint, GLint, GLsizei, GLfloat*);
       |    alias da_glGetnUniformivARB = void function(GLuint, GLint, GLsizei, GLint*);
       |    alias da_glGetnUniformuivARB = void function(GLuint, GLint, GLsizei, GLuint*);
       |    alias da_glGetnUniformdvARB = void function(GLuint, GLint, GLsizei, GLdouble*);
       |}
       |
       |__gshared {
       |    da_glGetGraphicsResetStatusARB glGetGraphicsResetStatusARB;
       |    da_glGetnMapdvARB glGetnMapdvARB;
       |    da_glGetnMapfvARB glGetnMapfvARB;
       |    da_glGetnMapivARB glGetnMapivARB;
       |    da_glGetnPixelMapfvARB glGetnPixelMapfvARB;
       |    da_glGetnPixelMapuivARB glGetnPixelMapuivARB;
       |    da_glGetnPixelMapusvARB glGetnPixelMapusvARB;
       |    da_glGetnPolygonStippleARB glGetnPolygonStippleARB;
       |    da_glGetnColorTableARB glGetnColorTableARB;
       |    da_glGetnConvolutionFilterARB glGetnConvolutionFilterARB;
       |    da_glGetnSeparableFilterARB glGetnSeparableFilterARB;
       |    da_glGetnHistogramARB glGetnHistogramARB;
       |    da_glGetnMinmaxARB glGetnMinmaxARB;
       |    da_glGetnTexImageARB glGetnTexImageARB;
       |    da_glReadnPixelsARB glReadnPixelsARB;
       |    da_glGetnCompressedTexImageARB glGetnCompressedTexImageARB;
       |    da_glGetnUniformfvARB glGetnUniformfvARB;
       |    da_glGetnUniformivARB glGetnUniformivARB;
       |    da_glGetnUniformuivARB glGetnUniformuivARB;
       |    da_glGetnUniformdvARB glGetnUniformdvARB;
       |}
       |
       |private __gshared bool _ARB_robustness;
0000000|@nogc bool ARB_robustness() nothrow @property { return _ARB_robustness; }
       |package void load_ARB_robustness() {
       |    try {
0000000|        bindGLFunc(cast(void**)&glGetGraphicsResetStatusARB, "glGetGraphicsResetStatusARB");
0000000|        bindGLFunc(cast(void**)&glGetnMapdvARB, "glGetnMapdvARB");
0000000|        bindGLFunc(cast(void**)&glGetnMapfvARB, "glGetnMapfvARB");
0000000|        bindGLFunc(cast(void**)&glGetnMapivARB, "glGetnMapivARB");
0000000|        bindGLFunc(cast(void**)&glGetnPixelMapfvARB, "glGetnPixelMapfvARB");
0000000|        bindGLFunc(cast(void**)&glGetnPixelMapuivARB, "glGetnPixelMapuivARB");
0000000|        bindGLFunc(cast(void**)&glGetnPixelMapusvARB, "glGetnPixelMapusvARB");
0000000|        bindGLFunc(cast(void**)&glGetnPolygonStippleARB, "glGetnPolygonStippleARB");
0000000|        bindGLFunc(cast(void**)&glGetnColorTableARB, "glGetnColorTableARB");
0000000|        bindGLFunc(cast(void**)&glGetnConvolutionFilterARB, "glGetnConvolutionFilterARB");
0000000|        bindGLFunc(cast(void**)&glGetnSeparableFilterARB, "glGetnSeparableFilterARB");
0000000|        bindGLFunc(cast(void**)&glGetnHistogramARB, "glGetnHistogramARB");
0000000|        bindGLFunc(cast(void**)&glGetnMinmaxARB, "glGetnMinmaxARB");
0000000|        bindGLFunc(cast(void**)&glGetnTexImageARB, "glGetnTexImageARB");
0000000|        bindGLFunc(cast(void**)&glReadnPixelsARB, "glReadnPixelsARB");
0000000|        bindGLFunc(cast(void**)&glGetnCompressedTexImageARB, "glGetnCompressedTexImageARB");
0000000|        bindGLFunc(cast(void**)&glGetnCompressedTexImageARB, "glGetnCompressedTexImageARB");
0000000|        bindGLFunc(cast(void**)&glGetnUniformfvARB, "glGetnUniformfvARB");
0000000|        bindGLFunc(cast(void**)&glGetnUniformivARB, "glGetnUniformivARB");
0000000|        bindGLFunc(cast(void**)&glGetnUniformuivARB, "glGetnUniformuivARB");
0000000|        bindGLFunc(cast(void**)&glGetnUniformdvARB, "glGetnUniformdvARB");
0000000|        _ARB_robustness = true;
       |    } catch(Exception e) {
0000000|        _ARB_robustness = false;
       |    }
       |}
       |
       |// ARB_base_instance
       |extern(System) @nogc nothrow {
       |    alias da_glDrawArraysInstancedBaseInstance = void function(GLenum, GLint, GLsizei, GLsizei, GLuint);
       |    alias da_glDrawElementsInstancedBaseInstance = void function(GLenum, GLsizei, GLenum, const(void)*, GLsizei, GLuint);
       |    alias da_glDrawElementsInstancedBaseVertexBaseInstance = void function(GLenum, GLsizei, GLenum, const(void)*, GLsizei, GLint, GLuint);
       |}
       |
       |__gshared {
       |    da_glDrawArraysInstancedBaseInstance glDrawArraysInstancedBaseInstance;
       |    da_glDrawElementsInstancedBaseInstance glDrawElementsInstancedBaseInstance;
       |    da_glDrawElementsInstancedBaseVertexBaseInstance glDrawElementsInstancedBaseVertexBaseInstance;
       |}
       |
       |private __gshared bool _ARB_base_instance;
0000000|@nogc bool ARB_base_instance() nothrow @property { return _ARB_base_instance; }
       |package void load_ARB_base_instance(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glDrawArraysInstancedBaseInstance, "glDrawArraysInstancedBaseInstance");
0000000|        bindGLFunc(cast(void**)&glDrawElementsInstancedBaseInstance, "glDrawElementsInstancedBaseInstance");
0000000|        bindGLFunc(cast(void**)&glDrawElementsInstancedBaseVertexBaseInstance, "glDrawElementsInstancedBaseVertexBaseInstance");
0000000|        _ARB_base_instance = true;
       |    } catch(Exception e) {
0000000|        _ARB_base_instance = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_transform_feedback_instanced
       |extern(System) @nogc nothrow {
       |    alias da_glDrawTransformFeedbackInstanced = void function(GLenum, GLuint, GLsizei);
       |    alias da_glDrawTransformFeedbackStreamInstanced = void function(GLenum, GLuint, GLuint, GLsizei);
       |}
       |__gshared da_glDrawTransformFeedbackInstanced glDrawTransformFeedbackInstanced;
       |__gshared da_glDrawTransformFeedbackStreamInstanced glDrawTransformFeedbackStreamInstanced;
       |
       |private __gshared bool _ARB_transform_feedback_instanced;
0000000|@nogc bool ARB_transform_feedback_instanced() nothrow @property { return _ARB_transform_feedback_instanced; }
       |package void load_ARB_transform_feedback_instanced(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glDrawTransformFeedbackInstanced, "glDrawTransformFeedbackInstanced");
0000000|        bindGLFunc(cast(void**)&glDrawTransformFeedbackStreamInstanced, "glDrawTransformFeedbackStreamInstanced");
0000000|        _ARB_transform_feedback_instanced = true;
       |    } catch(Exception e) {
0000000|        _ARB_transform_feedback_instanced = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_internalformat_query
       |extern(System) @nogc nothrow alias da_glGetInternalformativ = void function(GLenum, GLenum, GLenum, GLsizei, GLint*);
       |__gshared da_glGetInternalformativ glGetInternalformativ;
       |
       |private __gshared bool _ARB_internalformat_query;
0000000|@nogc bool ARB_internalformat_query() nothrow @property { return _ARB_internalformat_query; }
       |package void load_ARB_internalformat_query(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glGetInternalformativ, "glGetInternalformativ");
0000000|        _ARB_internalformat_query = true;
       |    } catch(Exception e) {
0000000|        _ARB_internalformat_query = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_shader_atomic_counters
       |extern(System) @nogc nothrow alias da_glGetActiveAtomicCounterBufferiv = void function(GLuint, GLuint, GLenum, GLint*);
       |__gshared da_glGetActiveAtomicCounterBufferiv glGetActiveAtomicCounterBufferiv;
       |
       |private __gshared bool _ARB_shader_atomic_counters;
0000000|@nogc bool ARB_shader_atomic_counters() nothrow @property { return _ARB_shader_atomic_counters; }
       |package void load_ARB_shader_atomic_counters(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glGetActiveAtomicCounterBufferiv, "glGetActiveAtomicCounterBufferiv");
0000000|        _ARB_shader_atomic_counters = true;
       |    } catch(Exception e) {
0000000|        _ARB_shader_atomic_counters = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_shader_image_load_store
       |extern(System) @nogc nothrow {
       |    alias da_glBindImageTexture = void function(GLuint, GLuint, GLint, GLboolean, GLint, GLenum, GLenum);
       |    alias da_glMemoryBarrier = void function(GLbitfield);
       |}
       |__gshared da_glBindImageTexture glBindImageTexture;
       |__gshared da_glMemoryBarrier glMemoryBarrier;
       |
       |private __gshared bool _ARB_shader_image_load_store;
0000000|@nogc bool ARB_shader_image_load_store() nothrow @property { return _ARB_shader_image_load_store; }
       |package void load_ARB_shader_image_load_store(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glBindImageTexture, "glBindImageTexture");
0000000|        bindGLFunc(cast(void**)&glMemoryBarrier, "glMemoryBarrier");
0000000|        _ARB_shader_image_load_store = true;
       |    } catch(Exception e) {
0000000|        _ARB_shader_image_load_store = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_texture_storage
       |extern(System) @nogc nothrow {
       |    alias da_glTexStorage1D = void function(GLenum, GLsizei, GLenum, GLsizei);
       |    alias da_glTexStorage2D = void function(GLenum, GLsizei, GLenum, GLsizei, GLsizei);
       |    alias da_glTexStorage3D = void function(GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei);
       |    alias da_glTextureStorage1DEXT = void function(GLuint, GLenum, GLsizei, GLenum, GLsizei);
       |    alias da_glTextureStorage2DEXT = void function(GLuint, GLenum, GLsizei, GLenum, GLsizei, GLsizei);
       |    alias da_glTextureStorage3DEXT = void function(GLuint, GLenum, GLsizei, GLenum, GLsizei, GLsizei, GLsizei);
       |}
       |
       |__gshared {
       |    da_glTexStorage1D glTexStorage1D;
       |    da_glTexStorage2D glTexStorage2D;
       |    da_glTexStorage3D glTexStorage3D;
       |    da_glTextureStorage1DEXT glTextureStorage1DEXT;
       |    da_glTextureStorage2DEXT glTextureStorage2DEXT;
       |    da_glTextureStorage3DEXT glTextureStorage3DEXT;
       |}
       |
       |private __gshared bool _ARB_texture_storage;
0000000|@nogc bool ARB_texture_storage() nothrow @property { return _ARB_texture_storage; }
       |package void load_ARB_texture_storage(GLVersion glversion, bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glTexStorage1D, "glTexStorage1D");
0000000|        bindGLFunc(cast(void**)&glTexStorage2D, "glTexStorage2D");
0000000|        bindGLFunc(cast(void**)&glTexStorage3D, "glTexStorage3D");
       |
0000000|        _ARB_texture_storage = true;
       |    } catch(Exception e) {
0000000|        _ARB_texture_storage = false;
0000000|        if(doThrow) throw e;
       |    }
       |    // The next three depend on the presence of EXT_direct_state_access.
0000000|    if(isExtSupported(glversion, "GL_EXT_direct_state_access")) {
0000000|        bindGLFunc(cast(void**)&glTextureStorage1DEXT, "glTextureStorage1DEXT");
0000000|        bindGLFunc(cast(void**)&glTextureStorage2DEXT, "glTextureStorage2DEXT");
0000000|        bindGLFunc(cast(void**)&glTextureStorage3DEXT, "glTextureStorage3DEXT");
       |    }
       |}
       |
       |// ARB_array_of_arrays
       |private __gshared bool _ARB_array_of_arrays;
0000000|@nogc bool ARB_array_of_arrays() nothrow @property { return _ARB_array_of_arrays; }
       |
       |// ARB_fragment_layer_viewport
       |private __gshared bool _ARB_fragment_layer_viewport;
0000000|@nogc bool ARB_fragment_layer_viewport() nothrow @property { return _ARB_fragment_layer_viewport; }
       |
       |// ARB_shader_image_size
       |private __gshared bool _ARB_shader_image_size;
0000000|@nogc bool ARB_shader_image_size() nothrow @property { return _ARB_shader_image_size; }
       |
       |// ARB_ES3_compatibility
       |private __gshared bool _ARB_ES3_compatibility;
0000000|@nogc bool ARB_ES3_compatibility() nothrow @property { return _ARB_ES3_compatibility; }
       |
       |// ARB_clear_buffer_object
       |extern(System) @nogc nothrow {
       |    alias da_glClearBufferData = void function(GLenum,GLenum,GLenum,GLenum,const(void)*);
       |    alias da_glClearBufferSubData = void function(GLenum,GLenum,GLintptr,GLsizeiptr,GLenum,GLenum,const(void)*);
       |    alias da_glClearNamedBufferDataEXT = void function(GLuint,GLenum,GLenum,GLenum,const(void)*);
       |    alias da_glClearNamedBufferSubDataEXT = void function(GLuint,GLenum,GLenum,GLenum,GLsizeiptr,GLsizeiptr,const(void)*);
       |}
       |
       |__gshared {
       |    da_glClearBufferData glClearBufferData;
       |    da_glClearBufferSubData glClearBufferSubData;
       |    da_glClearNamedBufferDataEXT glClearNamedBufferDataEXT;
       |    da_glClearNamedBufferSubDataEXT glClearNamedBufferSubDataEXT;
       |}
       |private __gshared bool _ARB_clear_buffer_object;
0000000|@nogc bool ARB_clear_buffer_object() nothrow @property { return _ARB_clear_buffer_object; }
       |package void load_ARB_clear_buffer_object(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glClearBufferData, "glClearBufferData");
0000000|        bindGLFunc(cast(void**)&glClearBufferSubData, "glClearBufferSubData");
0000000|        bindGLFunc(cast(void**)&glClearNamedBufferDataEXT, "glClearNamedBufferDataEXT");
0000000|        bindGLFunc(cast(void**)&glClearNamedBufferSubDataEXT, "glClearNamedBufferSubDataEXT");
0000000|        _ARB_clear_buffer_object = true;
       |    } catch(Exception e) {
0000000|        _ARB_clear_buffer_object = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_compute_shader
       |extern(System) @nogc nothrow {
       |    alias da_glDispatchCompute = void function(GLuint,GLuint,GLuint);
       |    alias da_glDispatchComputeIndirect = void function(GLintptr);
       |}
       |
       |__gshared {
       |    da_glDispatchCompute glDispatchCompute;
       |    da_glDispatchComputeIndirect glDispatchComputeIndirect;
       |}
       |private __gshared bool _ARB_compute_shader;
0000000|@nogc bool ARB_compute_shader() nothrow @property { return _ARB_compute_shader; }
       |package void load_ARB_compute_shader(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glDispatchCompute, "glDispatchCompute");
0000000|        bindGLFunc(cast(void**)&glDispatchComputeIndirect, "glDispatchComputeIndirect");
0000000|        _ARB_compute_shader = true;
       |    } catch(Exception e) {
0000000|        _ARB_compute_shader = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_copy_image
       |extern(System) @nogc nothrow
       |    alias da_glCopyImageSubData = void function(GLuint,GLenum,GLint,GLint,GLint,GLint,GLuint,GLenum,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei);
       |__gshared da_glCopyImageSubData glCopyImageSubData;
       |
       |private __gshared bool _ARB_copy_image;
0000000|@nogc bool ARB_copy_image() nothrow @property { return _ARB_copy_image; }
       |package void load_ARB_copy_image(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glCopyImageSubData, "glCopyImageSubData");
0000000|        _KHR_debug = true;
       |    } catch(Exception e) {
0000000|        _KHR_debug = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// KHR_debug
       |extern(System) @nogc nothrow {
       |    alias da_glDebugMessageControl = void function(GLenum,GLenum,GLenum,GLsizei,const(GLuint*),GLboolean);
       |    alias da_glDebugMessageInsert = void function(GLenum,GLenum,GLuint,GLenum,GLsizei,const(GLchar)*);
       |    alias da_glDebugMessageCallback = void function(GLDEBUGPROC,const(void)*);
       |    alias da_glGetDebugMessageLog = GLuint function(GLuint,GLsizei,GLenum*,GLenum*,GLuint*,GLenum*,GLsizei*,GLchar*);
       |    alias da_glPushDebugGroup = void function(GLenum,GLuint,GLsizei,const(GLchar)*);
       |    alias da_glPopDebugGroup = void function();
       |    alias da_glObjectLabel = void function(GLenum,GLuint,GLsizei,const(GLchar)*);
       |    alias da_glGetObjectLabel = void function(GLenum,GLuint,GLsizei,GLsizei*,GLchar*);
       |    alias da_glObjectPtrLabel = void function(const(void)*,GLsizei,const(GLchar)*);
       |    alias da_glGetObjectPtrLabel = void function(const(void)*,GLsizei,GLsizei*,GLchar*);
       |
       |}
       |__gshared {
       |    da_glDebugMessageControl glDebugMessageControl;
       |    da_glDebugMessageInsert glDebugMessageInsert;
       |    da_glDebugMessageCallback glDebugMessageCallback;
       |    da_glGetDebugMessageLog glGetDebugMessageLog;
       |    da_glPushDebugGroup glPushDebugGroup;
       |    da_glPopDebugGroup glPopDebugGroup;
       |    da_glObjectLabel glObjectLabel;
       |    da_glGetObjectLabel glGetObjectLabel;
       |    da_glObjectPtrLabel glObjectPtrLabel;
       |    da_glGetObjectPtrLabel glGetObjectPtrLabel;
       |}
       |private __gshared bool _KHR_debug;
0000000|@nogc bool KHR_debug() nothrow @property { return _KHR_debug; }
       |package void load_KHR_debug(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glDebugMessageControl, "glDebugMessageControl");
0000000|        bindGLFunc(cast(void**)&glDebugMessageInsert, "glDebugMessageInsert");
0000000|        bindGLFunc(cast(void**)&glDebugMessageCallback, "glDebugMessageCallback");
0000000|        bindGLFunc(cast(void**)&glGetDebugMessageLog, "glGetDebugMessageLog");
0000000|        bindGLFunc(cast(void**)&glPushDebugGroup, "glPushDebugGroup");
0000000|        bindGLFunc(cast(void**)&glPopDebugGroup, "glPopDebugGroup");
0000000|        bindGLFunc(cast(void**)&glObjectLabel, "glObjectLabel");
0000000|        bindGLFunc(cast(void**)&glGetObjectLabel, "glGetObjectLabel");
0000000|        bindGLFunc(cast(void**)&glObjectPtrLabel, "glObjectPtrLabel");
0000000|        bindGLFunc(cast(void**)&glGetObjectPtrLabel, "glGetObjectPtrLabel");
0000000|        _KHR_debug = true;
       |    } catch(Exception e) {
0000000|        _KHR_debug = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_explicit_uniform_location
       |private __gshared bool _ARB_explicit_uniform_location;
0000000|@nogc bool ARB_explicit_uniform_location() nothrow @property { return _ARB_explicit_uniform_location; }
       |
       |// ARB_framebuffer_no_attachments
       |extern(System) @nogc nothrow {
       |    alias da_glFramebufferParameteri = void function(GLenum,GLenum,GLint);
       |    alias da_glGetFramebufferParameteriv = void function(GLenum,GLenum,GLint*);
       |    alias da_glNamedFramebufferParameteriEXT = void function(GLuint,GLenum,GLint);
       |    alias da_glGetNamedFramebufferParameterivEXT = void function(GLuint,GLenum,GLint*);
       |}
       |
       |__gshared {
       |    da_glFramebufferParameteri glFramebufferParameteri;
       |    da_glGetFramebufferParameteriv glGetFramebufferParameteriv;
       |    da_glNamedFramebufferParameteriEXT glNamedFramebufferParameteriEXT;
       |    da_glGetNamedFramebufferParameterivEXT glGetNamedFramebufferParameterivEXT;
       |}
       |private __gshared bool _ARB_framebuffer_no_attachments;
0000000|@nogc bool ARB_framebuffer_no_attachments() nothrow @property { return _ARB_framebuffer_no_attachments; }
       |package void load_ARB_framebuffer_no_attachments(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glFramebufferParameteri, "glFramebufferParameteri");
0000000|        bindGLFunc(cast(void**)&glGetFramebufferParameteriv, "glGetFramebufferParameteriv");
0000000|        bindGLFunc(cast(void**)&glNamedFramebufferParameteriEXT, "glNamedFramebufferParameteriEXT");
0000000|        bindGLFunc(cast(void**)&glGetNamedFramebufferParameterivEXT, "glGetNamedFramebufferParameterivEXT");
0000000|        _ARB_framebuffer_no_attachments = true;
       |    } catch(Exception e) {
0000000|        _ARB_framebuffer_no_attachments = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_internalformat_query2
       |extern(System) @nogc nothrow alias da_glGetInternalformati64v = void function(GLenum,GLenum,GLenum,GLsizei,GLint64*);
       |__gshared da_glGetInternalformati64v glGetInternalformati64v;
       |private __gshared bool _ARB_internalformat_query2;
0000000|@nogc bool ARB_internalformat_query2() nothrow @property { return _ARB_internalformat_query2; }
       |package void load_ARB_internalformat_query2(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glGetInternalformati64v, "glGetInternalformati64v");
0000000|        _ARB_internalformat_query2 = true;
       |    } catch(Exception e) {
0000000|        _ARB_internalformat_query2 = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_invalidate_subdata
       |extern(System) @nogc nothrow {
       |    alias da_glInvalidateTexSubImage = void function(GLuint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei);
       |    alias da_glInvalidateTexImage = void function(GLuint,GLint);
       |    alias da_glInvalidateBufferSubData = void function(GLuint,GLintptr,GLsizeiptr);
       |    alias da_glInvalidateBufferData = void function(GLuint);
       |    alias da_glInvalidateFramebuffer = void function(GLenum,GLsizei,const(GLenum)*);
       |    alias da_glInvalidateSubFramebuffer = void function(GLenum,GLsizei,const(GLenum)*,GLint,GLint,GLsizei,GLsizei);
       |}
       |
       |__gshared {
       |    da_glInvalidateTexSubImage glInvalidateTexSubImage;
       |    da_glInvalidateTexImage glInvalidateTexImage;
       |    da_glInvalidateBufferSubData glInvalidateBufferSubData;
       |    da_glInvalidateBufferData glInvalidateBufferData;
       |    da_glInvalidateFramebuffer glInvalidateFramebuffer;
       |    da_glInvalidateSubFramebuffer glInvalidateSubFramebuffer;
       |}
       |private __gshared bool _ARB_invalidate_subdata;
0000000|@nogc bool ARB_invalidate_subdata() nothrow @property { return _ARB_invalidate_subdata; }
       |package void load_ARB_invalidate_subdata(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glInvalidateTexSubImage, "glInvalidateTexSubImage");
0000000|        bindGLFunc(cast(void**)&glInvalidateTexImage, "glInvalidateTexImage");
0000000|        bindGLFunc(cast(void**)&glInvalidateBufferSubData, "glInvalidateBufferSubData");
0000000|        bindGLFunc(cast(void**)&glInvalidateBufferData, "glInvalidateBufferData");
0000000|        bindGLFunc(cast(void**)&glInvalidateFramebuffer, "glInvalidateFramebuffer");
0000000|        bindGLFunc(cast(void**)&glInvalidateSubFramebuffer, "glInvalidateSubFramebuffer");
0000000|        _ARB_invalidate_subdata = true;
       |    }
       |    catch(Exception e) {
0000000|        _ARB_invalidate_subdata = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_multi_draw_indirect
       |extern(System) @nogc nothrow {
       |    alias da_glMultiDrawArraysIndirect = void function(GLenum,const(void)*,GLsizei,GLsizei);
       |    alias da_glMultiDrawElementsIndirect = void function(GLenum,GLenum,const(void)*,GLsizei,GLsizei);
       |}
       |__gshared da_glMultiDrawArraysIndirect glMultiDrawArraysIndirect;
       |__gshared da_glMultiDrawElementsIndirect glMultiDrawElementsIndirect;
       |private __gshared bool _ARB_multi_draw_indirect;
0000000|@nogc bool ARB_multi_draw_indirect() nothrow @property { return _ARB_multi_draw_indirect; }
       |package void load_ARB_multi_draw_indirect(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glMultiDrawArraysIndirect, "glMultiDrawArraysIndirect");
0000000|        bindGLFunc(cast(void**)&glMultiDrawElementsIndirect, "glMultiDrawElementsIndirect");
0000000|        _ARB_multi_draw_indirect = true;
       |    } catch(Exception e) {
0000000|        _ARB_multi_draw_indirect = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_program_interface_query
       |extern(System) @nogc nothrow {
       |    alias da_glGetProgramInterfaceiv = void function(GLuint,GLenum,GLenum,GLint*);
       |    alias da_glGetProgramResourceIndex = GLuint function(GLuint,GLenum,const(GLchar)*);
       |    alias da_glGetProgramResourceName = void function(GLuint,GLenum,GLuint,GLsizei,GLsizei*,GLchar*);
       |    alias da_glGetProgramResourceiv = void function(GLuint,GLenum,GLuint,GLsizei,const(GLenum)*,GLsizei,GLsizei*,GLint*);
       |    alias da_glGetProgramResourceLocation = GLint function(GLuint,GLenum,const(GLchar)*);
       |    alias da_glGetProgramResourceLocationIndex = GLint function(GLuint,GLenum,const(GLchar)*);
       |}
       |
       |__gshared {
       |    da_glGetProgramInterfaceiv glGetProgramInterfaceiv;
       |    da_glGetProgramResourceIndex glGetProgramResourceIndex;
       |    da_glGetProgramResourceName glGetProgramResourceName;
       |    da_glGetProgramResourceiv glGetProgramResourceiv;
       |    da_glGetProgramResourceLocation glGetProgramResourceLocation;
       |    da_glGetProgramResourceLocationIndex glGetProgramResourceLocationIndex;
       |}
       |
       |private __gshared bool _ARB_program_interface_query;
0000000|@nogc bool ARB_program_interface_query() nothrow @property { return _ARB_program_interface_query; }
       |package void load_ARB_program_interface_query(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glGetProgramInterfaceiv, "glGetProgramInterfaceiv");
0000000|        bindGLFunc(cast(void**)&glGetProgramResourceIndex, "glGetProgramResourceIndex");
0000000|        bindGLFunc(cast(void**)&glGetProgramResourceName, "glGetProgramResourceName");
0000000|        bindGLFunc(cast(void**)&glGetProgramResourceiv, "glGetProgramResourceiv");
0000000|        bindGLFunc(cast(void**)&glGetProgramResourceLocation, "glGetProgramResourceLocation");
0000000|        bindGLFunc(cast(void**)&glGetProgramResourceLocationIndex, "glGetProgramResourceLocationIndex");
0000000|        _ARB_program_interface_query = true;
       |    } catch(Exception e) {
0000000|        _ARB_program_interface_query = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_robust_buffer_access_behavior
       |private __gshared bool _ARB_robust_buffer_access_behavior;
0000000|@nogc bool ARB_robust_buffer_access_behavior() nothrow @property { return _ARB_robust_buffer_access_behavior; }
       |
       |// ARB_shader_storage_buffer_object
       |extern(System) alias da_glShaderStorageBlockBinding = void function(GLuint,GLuint,GLuint);
       |__gshared da_glShaderStorageBlockBinding glShaderStorageBlockBinding;
       |private __gshared bool _ARB_shader_storage_buffer_object;
0000000|@nogc bool ARB_shader_storage_buffer_object() nothrow @property { return _ARB_shader_storage_buffer_object; }
       |package void load_ARB_shader_storage_buffer_object(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glShaderStorageBlockBinding, "glShaderStorageBlockBinding");
0000000|        _ARB_shader_storage_buffer_object = true;
       |    } catch(Exception e) {
0000000|        _ARB_shader_storage_buffer_object = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_stencil_texturing
       |private __gshared bool _ARB_stencil_texturing;
0000000|@nogc bool ARB_stencil_texturing() nothrow @property { return _ARB_stencil_texturing; }
       |
       |// ARB_texture_buffer_range
       |extern(System) @nogc nothrow {
       |    alias da_glTexBufferRange = void function(GLenum,GLenum,GLuint,GLintptr,GLsizeiptr);
       |    alias da_glTextureBufferRangeEXT = void function(GLuint,GLenum,GLenum,GLuint,GLintptr,GLsizeiptr);
       |}
       |__gshared da_glTexBufferRange glTexBufferRange;
       |__gshared da_glTextureBufferRangeEXT glTextureBufferRangeEXT;
       |private __gshared bool _ARB_texture_buffer_range;
0000000|@nogc bool ARB_texture_buffer_range() nothrow @property { return _ARB_texture_buffer_range; }
       |package void load_ARB_texture_buffer_range(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glTexBufferRange, "glTexBufferRange");
0000000|        bindGLFunc(cast(void**)&glTextureBufferRangeEXT, "glTextureBufferRangeEXT");
0000000|        _ARB_texture_buffer_range = true;
       |    } catch(Exception e) {
0000000|        _ARB_texture_buffer_range = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_texture_query_levels
       |private __gshared bool _ARB_texture_query_levels;
0000000|@nogc bool ARB_texture_query_levels() nothrow @property { return _ARB_texture_query_levels; }
       |
       |// ARB_texture_storage_multisample
       |extern(System) @nogc nothrow {
       |    alias da_glTexStorage2DMultisample = void function(GLenum,GLsizei,GLenum,GLsizei,GLsizei,GLboolean);
       |    alias da_glTexStorage3DMultisample = void function(GLenum,GLsizei,GLenum,GLsizei,GLsizei,GLsizei,GLboolean);
       |    alias da_glTextureStorage2DMultisampleEXT = void function(GLuint,GLenum,GLsizei,GLenum,GLsizei,GLsizei,GLboolean);
       |    alias da_glTextureStorage3DMultisampleEXT = void function(GLuint,GLenum,GLsizei,GLenum,GLsizei,GLsizei,GLsizei,GLboolean);
       |}
       |
       |__gshared {
       |    da_glTexStorage2DMultisample glTexStorage2DMultisample;
       |    da_glTexStorage3DMultisample glTexStorage3DMultisample;
       |    da_glTextureStorage2DMultisampleEXT glTextureStorage2DMultisampleEXT;
       |    da_glTextureStorage3DMultisampleEXT glTextureStorage3DMultisampleEXT;
       |}
       |
       |private __gshared bool _ARB_texture_storage_multisample;
0000000|@nogc bool ARB_texture_storage_multisample() nothrow @property { return _ARB_texture_storage_multisample; }
       |package void load_ARB_texture_storage_multisample(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glTexStorage2DMultisample, "glTexStorage2DMultisample");
0000000|        bindGLFunc(cast(void**)&glTexStorage3DMultisample, "glTexStorage3DMultisample");
0000000|        bindGLFunc(cast(void**)&glTextureStorage2DMultisampleEXT, "glTextureStorage2DMultisampleEXT");
0000000|        bindGLFunc(cast(void**)&glTextureStorage3DMultisampleEXT, "glTextureStorage3DMultisampleEXT");
0000000|        _ARB_texture_storage_multisample = true;
       |    } catch(Exception e) {
0000000|        _ARB_texture_storage_multisample = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_texture_view
       |extern(System) @nogc nothrow alias da_glTextureView = void function(GLuint,GLenum,GLuint,GLenum,GLuint,GLuint,GLuint,GLuint);
       |__gshared da_glTextureView glTextureView;
       |private __gshared bool _ARB_texture_view;
0000000|@nogc bool ARB_texture_view() nothrow @property { return _ARB_texture_view; }
       |package void load_ARB_texture_view(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glTextureView, "glTextureView");
0000000|        _ARB_texture_view = true;
       |    } catch(Exception e) {
0000000|        _ARB_texture_view = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_vertex_attrib_binding
       |extern(System) @nogc nothrow {
       |    alias da_glBindVertexBuffer = void function(GLuint,GLuint,GLintptr,GLsizei);
       |    alias da_glVertexAttribFormat = void function(GLuint,GLint,GLenum,GLboolean,GLuint);
       |    alias da_glVertexAttribIFormat = void function(GLuint,GLint,GLenum,GLuint);
       |    alias da_glVertexAttribLFormat = void function(GLuint,GLint,GLenum,GLuint);
       |    alias da_glVertexAttribBinding = void function(GLuint,GLuint);
       |    alias da_glVertexBindingDivisor = void function(GLuint,GLuint);
       |    alias da_glVertexArrayBindVertexBufferEXT = void function(GLuint,GLuint,GLuint,GLintptr,GLsizei);
       |    alias da_glVertexArrayVertexAttribFormatEXT = void function(GLuint,GLuint,GLint,GLenum,GLboolean,GLuint);
       |    alias da_glVertexArrayVertexAttribIFormatEXT = void function(GLuint,GLuint,GLint,GLenum,GLuint);
       |    alias da_glVertexArrayVertexAttribLFormatEXT = void function(GLuint,GLuint,GLint,GLenum,GLuint);
       |    alias da_glVertexArrayVertexAttribBindingEXT = void function(GLuint,GLuint,GLuint);
       |    alias da_glVertexArrayVertexBindingDivisorEXT = void function(GLuint,GLuint,GLuint);
       |}
       |
       |__gshared {
       |    da_glBindVertexBuffer glBindVertexBuffer;
       |    da_glVertexAttribFormat glVertexAttribFormat;
       |    da_glVertexAttribIFormat glVertexAttribIFormat;
       |    da_glVertexAttribLFormat glVertexAttribLFormat;
       |    da_glVertexAttribBinding glVertexAttribBinding;
       |    da_glVertexBindingDivisor glVertexBindingDivisor;
       |    da_glVertexArrayBindVertexBufferEXT glVertexArrayBindVertexBufferEXT;
       |    da_glVertexArrayVertexAttribFormatEXT glVertexArrayVertexAttribFormatEXT;
       |    da_glVertexArrayVertexAttribIFormatEXT glVertexArrayVertexAttribIFormatEXT;
       |    da_glVertexArrayVertexAttribLFormatEXT glVertexArrayVertexAttribLFormatEXT;
       |    da_glVertexArrayVertexAttribBindingEXT glVertexArrayVertexAttribBindingEXT;
       |    da_glVertexArrayVertexBindingDivisorEXT glVertexArrayVertexBindingDivisorEXT;
       |}
       |
       |private __gshared bool _ARB_vertex_attrib_binding;
0000000|@nogc bool ARB_vertex_attrib_binding() nothrow @property { return _ARB_vertex_attrib_binding; }
       |package void load_ARB_vertex_attrib_binding(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glBindVertexBuffer, "glBindVertexBuffer");
0000000|        bindGLFunc(cast(void**)&glVertexAttribFormat, "glVertexAttribFormat");
0000000|        bindGLFunc(cast(void**)&glVertexAttribIFormat, "glVertexAttribIFormat");
0000000|        bindGLFunc(cast(void**)&glVertexAttribLFormat, "glVertexAttribLFormat");
0000000|        bindGLFunc(cast(void**)&glVertexAttribBinding, "glVertexAttribBinding");
0000000|        bindGLFunc(cast(void**)&glVertexBindingDivisor, "glVertexBindingDivisor");
0000000|        bindGLFunc(cast(void**)&glVertexArrayBindVertexBufferEXT, "glVertexArrayBindVertexBufferEXT");
0000000|        bindGLFunc(cast(void**)&glVertexArrayVertexAttribFormatEXT, "glVertexArrayVertexAttribFormatEXT");
0000000|        bindGLFunc(cast(void**)&glVertexArrayVertexAttribIFormatEXT, "glVertexArrayVertexAttribIFormatEXT");
0000000|        bindGLFunc(cast(void**)&glVertexArrayVertexAttribLFormatEXT, "glVertexArrayVertexAttribLFormatEXT");
0000000|        bindGLFunc(cast(void**)&glVertexArrayVertexAttribBindingEXT, "glVertexArrayVertexAttribBindingEXT");
0000000|        bindGLFunc(cast(void**)&glVertexArrayVertexBindingDivisorEXT, "glVertexArrayVertexBindingDivisorEXT");
0000000|        _ARB_vertex_attrib_binding = true;
       |    } catch(Exception e) {
0000000|        _ARB_vertex_attrib_binding = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_buffer_storage
       |extern(System) @nogc nothrow {
       |    alias da_glBufferStorage = void function(GLenum,GLsizeiptr,const(void)*,GLbitfield);
       |    alias da_glNamedBufferStorageEXT = void function(GLuint,GLsizeiptr,const(void)*,GLbitfield);
       |}
       |
       |__gshared {
       |    da_glBufferStorage glBufferStorage;
       |    da_glNamedBufferStorageEXT glNamedBufferStorageEXT;
       |}
       |
       |private __gshared bool _ARB_buffer_storage;
0000000|@nogc bool ARB_buffer_storage() nothrow @property { return _ARB_buffer_storage; }
       |package void load_ARB_buffer_storage(GLVersion glversion, bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glBufferStorage, "glBufferStorage");
       |
       |        // This one depends on GL_EXT_direct_state_access
0000000|        if(isExtSupported(glversion, "GL_EXT_direct_state_access")) {
0000000|            bindGLFunc(cast(void**)&glNamedBufferStorageEXT, "glNamedBufferStorageEXT");
       |        }
0000000|        _ARB_buffer_storage = true;
       |    } catch(Exception e) {
0000000|        _ARB_buffer_storage = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_clear_texture
       |extern(System) @nogc nothrow {
       |    alias da_glClearTexImage = void function(GLuint,GLint,GLenum,GLenum,const(void)*);
       |    alias da_glClearTexSubImage = void function(GLuint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei,GLenum,GLenum,const(void)*);
       |}
       |
       |__gshared {
       |    da_glClearTexImage glClearTexImage;
       |    da_glClearTexSubImage glClearTexSubImage;
       |}
       |
       |private __gshared bool _ARB_clear_texture;
0000000|@nogc bool ARB_clear_texture() nothrow @property { return _ARB_clear_texture; }
       |package void load_ARB_clear_texture(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glClearTexImage, "glClearTexImage");
0000000|        bindGLFunc(cast(void**)&glClearTexSubImage, "glClearTexSubImage");
0000000|        _ARB_clear_texture = true;
       |    } catch(Exception e) {
0000000|        _ARB_clear_texture = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_enhanced_layouts
       |private __gshared bool _ARB_enhanced_layouts;
0000000|@nogc bool ARB_enhanced_layouts() nothrow @property { return _ARB_enhanced_layouts; }
       |
       |// ARB_multi_bind
       |extern(System) @nogc nothrow {
       |    alias da_glBindBuffersBase = void function(GLenum,GLuint,GLsizei,const(GLuint)*);
       |    alias da_glBindBuffersRange = void function(GLenum,GLuint,GLsizei,const(GLuint)*,const(GLintptr)*,const(GLsizeiptr)*);
       |    alias da_glBindTextures = void function(GLuint,GLsizei,const(GLuint)*);
       |    alias da_glBindSamplers = void function(GLuint,GLsizei,const(GLuint)*);
       |    alias da_glBindImageTextures = void function(GLuint,GLsizei,const(GLuint)*);
       |    alias da_glBindVertexBuffers = void function(GLuint,GLsizei,const(GLuint)*,const(GLintptr)*,const(GLsizei)*);
       |}
       |
       |__gshared {
       |    da_glBindBuffersBase glBindBuffersBase;
       |    da_glBindBuffersRange glBindBuffersRange;
       |    da_glBindTextures glBindTextures;
       |    da_glBindSamplers glBindSamplers;
       |    da_glBindImageTextures glBindImageTextures;
       |    da_glBindVertexBuffers glBindVertexBuffers;
       |}
       |
       |private __gshared bool _ARB_multi_bind;
0000000|@nogc bool ARB_multi_bind() nothrow @property { return _ARB_multi_bind; }
       |package void load_ARB_multi_bind(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glBindBuffersBase, "glBindBuffersBase");
0000000|        bindGLFunc(cast(void**)&glBindBuffersRange, "glBindBuffersRange");
0000000|        bindGLFunc(cast(void**)&glBindTextures, "glBindTextures");
0000000|        bindGLFunc(cast(void**)&glBindSamplers, "glBindSamplers");
0000000|        bindGLFunc(cast(void**)&glBindImageTextures, "glBindImageTextures");
0000000|        bindGLFunc(cast(void**)&glBindVertexBuffers, "glBindVertexBuffers");
0000000|        _ARB_multi_bind = true;
       |    } catch(Exception e) {
0000000|        _ARB_multi_bind = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_query_buffer_object
       |private __gshared bool _ARB_query_buffer_object;
0000000|@nogc bool ARB_query_buffer_object() nothrow @property { return _ARB_query_buffer_object; }
       |
       |// ARB_texture_mirror_clamp_to_edge
       |private __gshared bool _ARB_texture_mirror_clamp_to_edge;
0000000|@nogc bool ARB_texture_mirror_clamp_to_edge() nothrow @property { return _ARB_texture_mirror_clamp_to_edge; }
       |
       |// ARB_texture_stencil8
       |private __gshared bool _ARB_texture_stencil8;
0000000|@nogc bool ARB_texture_stencil8() nothrow @property { return _ARB_texture_stencil8; }
       |
       |// ARB_vertex_type_10f_11f_11f_rev
       |private __gshared bool _ARB_vertex_type_10f_11f_11f_rev;
0000000|@nogc bool ARB_vertex_type_10f_11f_11f_rev() nothrow @property { return _ARB_vertex_type_10f_11f_11f_rev; }
       |
       |// ARB_clip_control
       |extern(System) @nogc nothrow alias da_glClipControl = void function(GLenum,GLenum);
       |__gshared da_glClipControl glClipControl;
       |private __gshared bool _ARB_clip_control;
0000000|@nogc bool ARB_clip_control() nothrow @property { return _ARB_clip_control; }
       |package void load_ARB_clip_control(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glClipControl, "glClipControl");
0000000|        _ARB_clip_control = true;
       |    } catch(Exception e) {
0000000|        _ARB_clip_control = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_cull_distance
       |private __gshared bool _ARB_cull_distance;
0000000|@nogc bool ARB_cull_distance() nothrow @property { return _ARB_cull_distance; }
       |
       |// ARB_ES3_1_compatibility
       |extern(System) @nogc nothrow alias da_glMemoryBarrierByRegion = void function(GLbitfield);
       |__gshared da_glMemoryBarrierByRegion glMemoryBarrierByRegion;
       |private __gshared bool _ARB_ES3_1_compatibility;
0000000|@nogc bool ARB_ES3_1_compatibility() nothrow @property { return _ARB_ES3_1_compatibility; }
       |package void load_ARB_ES3_1_compatibility(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glMemoryBarrierByRegion, "glMemoryBarrierByRegion");
0000000|        _ARB_ES3_1_compatibility = true;
       |    } catch(Exception e) {
0000000|        _ARB_ES3_1_compatibility = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_conditional_render_inverted
       |private __gshared bool _ARB_conditional_render_inverted;
0000000|@nogc bool ARB_conditional_render_inverted() nothrow @property { return _ARB_conditional_render_inverted; }
       |
       |// KHR_context_flush_control
       |private __gshared bool _KHR_context_flush_control;
0000000|@nogc bool KHR_context_flush_control() nothrow @property { return _KHR_context_flush_control; }
       |
       |// ARB_derivative_control
       |private __gshared bool _ARB_derivative_control;
0000000|@nogc bool ARB_derivative_control() nothrow @property { return _ARB_derivative_control; }
       |
       |// ARB_direct_state_access
       |extern(System) @nogc nothrow {
       |    alias da_glCreateTransformFeedbacks = void function(GLsizei,GLuint*);
       |    alias da_glTransformFeedbackBufferBase = void function(GLsizei,GLuint,GLuint);
       |    alias da_glTransformFeedbackBufferRange = void function(GLuint,GLuint,GLuint,GLintptr,GLsizei);
       |    alias da_glGetTransformFeedbackiv = void function(GLuint,GLenum,GLint*);
       |    alias da_glGetTransformFeedbacki_v = void function(GLuint,GLenum,GLuint,GLint*);
       |    alias da_glGetTransformFeedbacki64_v = void function(GLuint,GLenum,GLuint,GLint64*);
       |    alias da_glCreateBuffers = void function(GLsizei,GLuint*);
       |    alias da_glNamedBufferStorage = void function(GLuint,GLsizeiptr,const(void)*,GLbitfield);
       |    alias da_glNamedBufferData = void function(GLuint,GLsizeiptr,const(void)*,GLenum);
       |    alias da_glNamedBufferSubData = void function(GLuint,GLintptr,GLsizeiptr,const(void)*);
       |    alias da_glCopyNamedBufferSubData = void function(GLuint,GLuint,GLintptr,GLintptr,GLsizeiptr);
       |    alias da_glClearNamedBufferData = void function(GLuint,GLenum,GLenum,GLenum,const(void)*);
       |    alias da_glClearNamedBufferSubData = void function(GLuint,GLenum,GLintptr,GLsizeiptr,GLenum,GLenum,const(void)*);
       |    alias da_glMapNamedBuffer = void* function(GLuint,GLenum);
       |    alias da_glMapNamedBufferRange = void* function(GLuint,GLintptr,GLsizeiptr,GLbitfield);
       |    alias da_glUnmapNamedBuffer = GLboolean function(GLuint);
       |    alias da_glFlushMappedNamedBufferRange = void function(GLuint,GLintptr,GLsizeiptr);
       |    alias da_glGetNamedBufferParameteriv = void function(GLuint,GLenum,GLint*);
       |    alias da_glGetNamedBufferParameteri64v = void function(GLuint,GLenum,GLint64*);
       |    alias da_glGetNamedBufferPointerv = void function(GLuint,GLenum,void**);
       |    alias da_glGetNamedBufferSubData = void function(GLuint,GLintptr,GLsizeiptr,void*);
       |    alias da_glCreateFramebuffers = void function(GLsizei,GLuint*);
       |    alias da_glNamedFramebufferRenderbuffer = void function(GLuint,GLenum,GLenum,GLuint);
       |    alias da_glNamedFramebufferParameteri = void function(GLuint,GLenum,GLint);
       |    alias da_glNamedFramebufferTexture = void function(GLuint,GLenum,GLuint,GLint);
       |    alias da_glNamedFramebufferTextureLayer = void function(GLuint,GLenum,GLuint,GLint,GLint);
       |    alias da_glNamedFramebufferDrawBuffer = void function(GLuint,GLenum);
       |    alias da_glNamedFramebufferDrawBuffers = void function(GLuint,GLsizei,const(GLenum)*);
       |    alias da_glNamedFramebufferReadBuffer = void function(GLuint,GLenum);
       |    alias da_glInvalidateNamedFramebufferData = void function(GLuint,GLsizei,const(GLenum)*);
       |    alias da_glInvalidateNamedFramebufferSubData = void function(GLuint,GLsizei,const(GLenum)*,GLint,GLint,GLsizei,GLsizei);
       |    alias da_glClearNamedFramebufferiv = void function(GLuint,GLenum,GLint,const(GLint)*);
       |    alias da_glClearNamedFramebufferuiv = void function(GLuint,GLenum,GLint,const(GLuint)*);
       |    alias da_glClearNamedFramebufferfv = void function(GLuint,GLenum,GLint,const(GLfloat)*);
       |    alias da_glClearNamedFramebufferfi = void function(GLuint,GLenum,GLfloat,GLint);
       |    alias da_glBlitNamedFramebuffer = void function(GLuint,GLuint,GLint,GLint,GLint,GLint,GLint,GLint,GLint,GLint,GLbitfield,GLenum);
       |    alias da_glCheckNamedFramebufferStatus = GLenum function(GLuint,GLenum);
       |    alias da_glGetNamedFramebufferParameteriv = void function(GLuint,GLenum,GLint*);
       |    alias da_glGetNamedFramebufferAttachmentParameteriv = void function(GLuint,GLenum,GLenum,GLint*);
       |    alias da_glCreateRenderbuffers = void function(GLsizei,GLuint*);
       |    alias da_glNamedRenderbufferStorage = void function(GLuint,GLenum,GLsizei,GLsizei);
       |    alias da_glNamedRenderbufferStorageMultisample = void function(GLuint,GLsizei,GLenum,GLsizei,GLsizei);
       |    alias da_glGetNamedRenderbufferParameteriv = void function(GLuint,GLenum,GLint*);
       |    alias da_glCreateTextures = void function(GLenum,GLsizei,GLuint*);
       |    alias da_glTextureBuffer = void function(GLuint,GLenum,GLuint);
       |    alias da_glTextureBufferRange = void function(GLuint,GLenum,GLuint,GLintptr,GLsizeiptr);
       |    alias da_glTextureStorage1D = void function(GLuint,GLsizei,GLenum,GLsizei);
       |    alias da_glTextureStorage2D = void function(GLuint,GLsizei,GLenum,GLsizei,GLsizei);
       |    alias da_glTextureStorage3D = void function(GLuint,GLsizei,GLenum,GLsizei,GLsizei,GLsizei);
       |    alias da_glTextureStorage2DMultisample = void function(GLuint,GLsizei,GLenum,GLsizei,GLsizei,GLboolean);
       |    alias da_glTextureStorage3DMultisample = void function(GLuint,GLsizei,GLenum,GLsizei,GLsizei,GLsizei,GLboolean);
       |    alias da_glTextureSubImage1D = void function(GLuint,GLint,GLint,GLsizei,GLenum,GLenum,const(void)*);
       |    alias da_glTextureSubImage2D = void function(GLuint,GLint,GLint,GLint,GLsizei,GLsizei,GLenum,GLenum,const(void)*);
       |    alias da_glTextureSubImage3D = void function(GLuint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei,GLenum,GLenum,const(void)*);
       |    alias da_glCompressedTextureSubImage1D = void function(GLuint,GLint,GLint,GLsizei,GLenum,GLsizei,const(void)*);
       |    alias da_glCompressedTextureSubImage2D = void function(GLuint,GLint,GLint,GLint,GLsizei,GLsizei,GLenum,GLsizei,const(void)*);
       |    alias da_glCompressedTextureSubImage3D = void function(GLuint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei,GLenum,GLsizei,const(void)*);
       |    alias da_glCopyTextureSubImage1D = void function(GLuint,GLint,GLint,GLint,GLint,GLsizei);
       |    alias da_glCopyTextureSubImage2D = void function(GLuint,GLint,GLint,GLint,GLint,GLint,GLsizei,GLsizei);
       |    alias da_glCopyTextureSubImage3D = void function(GLuint,GLint,GLint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei);
       |    alias da_glTextureParameterf = void function(GLuint,GLenum,GLfloat);
       |    alias da_glTextureParameterfv = void function(GLuint,GLenum,const(GLfloat)*);
       |    alias da_glTextureParameteri = void function(GLuint,GLenum,GLint);
       |    alias da_glTextureParameterIiv = void function(GLuint,GLenum,const(GLint)*);
       |    alias da_glTextureParameterIuiv = void function(GLuint,GLenum,const(GLuint)*);
       |    alias da_glTextureParameteriv = void function(GLuint,GLenum,const(GLint)*);
       |    alias da_glGenerateTextureMipmap = void function(GLuint);
       |    alias da_glBindTextureUnit = void function(GLuint,GLuint);
       |    alias da_glGetTextureImage = void function(GLuint,GLint,GLenum,GLenum,GLsizei,void*);
       |    alias da_glGetCompressedTextureImage = void function(GLuint,GLint,GLsizei,void*);
       |    alias da_glGetTextureLevelParameterfv = void function(GLuint,GLint,GLenum,GLfloat*);
       |    alias da_glGetTextureLevelParameteriv = void function(GLuint,GLint,GLenum,GLint*);
       |    alias da_glGetTextureParameterfv = void function(GLuint,GLenum,GLfloat*);
       |    alias da_glGetTextureParameterIiv = void function(GLuint,GLenum,GLint*);
       |    alias da_glGetTextureParameterIuiv = void function(GLuint,GLenum,GLuint*);
       |    alias da_glGetTextureParameteriv = void function(GLuint,GLenum,GLint*);
       |    alias da_glCreateVertexArrays = void function(GLsizei,GLuint*);
       |    alias da_glDisableVertexArrayAttrib = void function(GLuint,GLuint);
       |    alias da_glEnableVertexArrayAttrib = void function(GLuint,GLuint);
       |    alias da_glVertexArrayElementBuffer = void function(GLuint,GLuint);
       |    alias da_glVertexArrayVertexBuffer = void function(GLuint,GLuint,GLuint,GLintptr,GLsizei);
       |    alias da_glVertexArrayVertexBuffers = void function(GLuint,GLuint,GLsizei,const(GLuint)*,const(GLintptr)*,const(GLsizei)*);
       |    alias da_glVertexArrayAttribFormat = void function(GLuint,GLuint,GLint,GLenum,GLboolean,GLuint);
       |    alias da_glVertexArrayAttribIFormat = void function(GLuint,GLuint,GLint,GLenum,GLuint);
       |    alias da_glVertexArrayAttribLFormat = void function(GLuint,GLuint,GLint,GLenum,GLuint);
       |    alias da_glVertexArrayAttribBinding = void function(GLuint,GLuint,GLuint);
       |    alias da_glVertexArrayBindingDivisor = void function(GLuint,GLuint,GLuint);
       |    alias da_glGetVertexArrayiv = void function(GLuint,GLenum,GLint*);
       |    alias da_glGetVertexArrayIndexediv = void function(GLuint,GLuint,GLenum,GLint*);
       |    alias da_glGetVertexArrayIndexed64iv = void function(GLuint,GLuint,GLenum,GLint64*);
       |    alias da_glCreateSamplers = void function(GLsizei,GLuint*);
       |    alias da_glCreateProgramPipelines = void function(GLsizei,GLuint*);
       |    alias da_glCreateQueries = void function(GLenum,GLsizei,GLuint*);
       |    alias da_glGetQueryBufferObjectiv = void function(GLuint,GLuint,GLenum,GLintptr);
       |    alias da_glGetQueryBufferObjectuiv = void function(GLuint,GLuint,GLenum,GLintptr);
       |    alias da_glGetQueryBufferObjecti64v = void function(GLuint,GLuint,GLenum,GLintptr);
       |    alias da_glGetQueryBufferObjectui64v = void function(GLuint,GLuint,GLenum,GLintptr);
       |}
       |
       |__gshared {
       |    da_glCreateTransformFeedbacks glCreateTransformFeedbacks;
       |    da_glTransformFeedbackBufferBase glTransformFeedbackBufferBase;
       |    da_glTransformFeedbackBufferRange glTransformFeedbackBufferRange;
       |    da_glGetTransformFeedbackiv glGetTransformFeedbackiv;
       |    da_glGetTransformFeedbacki_v glGetTransformFeedbacki_v;
       |    da_glGetTransformFeedbacki64_v glGetTransformFeedbacki64_v;
       |    da_glCreateBuffers glCreateBuffers;
       |    da_glNamedBufferStorage glNamedBufferStorage;
       |    da_glNamedBufferData glNamedBufferData;
       |    da_glNamedBufferSubData glNamedBufferSubData;
       |    da_glCopyNamedBufferSubData glCopyNamedBufferSubData;
       |    da_glClearNamedBufferData glClearNamedBufferData;
       |    da_glClearNamedBufferSubData glClearNamedBufferSubData;
       |    da_glMapNamedBuffer glMapNamedBuffer;
       |    da_glMapNamedBufferRange glMapNamedBufferRange;
       |    da_glUnmapNamedBuffer glUnmapNamedBuffer;
       |    da_glFlushMappedNamedBufferRange glFlushMappedNamedBufferRange;
       |    da_glGetNamedBufferParameteriv glGetNamedBufferParameteriv;
       |    da_glGetNamedBufferParameteri64v glGetNamedBufferParameteri64v;
       |    da_glGetNamedBufferPointerv glGetNamedBufferPointerv;
       |    da_glGetNamedBufferSubData glGetNamedBufferSubData;
       |    da_glCreateFramebuffers glCreateFramebuffers;
       |    da_glNamedFramebufferRenderbuffer glNamedFramebufferRenderbuffer;
       |    da_glNamedFramebufferParameteri glNamedFramebufferParameteri;
       |    da_glNamedFramebufferTexture glNamedFramebufferTexture;
       |    da_glNamedFramebufferTextureLayer glNamedFramebufferTextureLayer;
       |    da_glNamedFramebufferDrawBuffer glNamedFramebufferDrawBuffer;
       |    da_glNamedFramebufferDrawBuffers glNamedFramebufferDrawBuffers;
       |    da_glNamedFramebufferReadBuffer glNamedFramebufferReadBuffer;
       |    da_glInvalidateNamedFramebufferData glInvalidateNamedFramebufferData;
       |    da_glInvalidateNamedFramebufferSubData glInvalidateNamedFramebufferSubData;
       |    da_glClearNamedFramebufferiv glClearNamedFramebufferiv;
       |    da_glClearNamedFramebufferuiv glClearNamedFramebufferuiv;
       |    da_glClearNamedFramebufferfv glClearNamedFramebufferfv;
       |    da_glClearNamedFramebufferfi glClearNamedFramebufferfi;
       |    da_glBlitNamedFramebuffer glBlitNamedFramebuffer;
       |    da_glCheckNamedFramebufferStatus glCheckNamedFramebufferStatus;
       |    da_glGetNamedFramebufferParameteriv glGetNamedFramebufferParameteriv;
       |    da_glGetNamedFramebufferAttachmentParameteriv glGetNamedFramebufferAttachmentParameteriv;
       |    da_glCreateRenderbuffers glCreateRenderbuffers;
       |    da_glNamedRenderbufferStorage glNamedRenderbufferStorage;
       |    da_glNamedRenderbufferStorageMultisample glNamedRenderbufferStorageMultisample;
       |    da_glGetNamedRenderbufferParameteriv glGetNamedRenderbufferParameteriv;
       |    da_glCreateTextures glCreateTextures;
       |    da_glTextureBuffer glTextureBuffer;
       |    da_glTextureBufferRange glTextureBufferRange;
       |    da_glTextureStorage1D glTextureStorage1D;
       |    da_glTextureStorage2D glTextureStorage2D;
       |    da_glTextureStorage3D glTextureStorage3D;
       |    da_glTextureStorage2DMultisample glTextureStorage2DMultisample;
       |    da_glTextureStorage3DMultisample glTextureStorage3DMultisample;
       |    da_glTextureSubImage1D glTextureSubImage1D;
       |    da_glTextureSubImage2D glTextureSubImage2D;
       |    da_glTextureSubImage3D glTextureSubImage3D;
       |    da_glCompressedTextureSubImage1D glCompressedTextureSubImage1D;
       |    da_glCompressedTextureSubImage2D glCompressedTextureSubImage2D;
       |    da_glCompressedTextureSubImage3D glCompressedTextureSubImage3D;
       |    da_glCopyTextureSubImage1D glCopyTextureSubImage1D;
       |    da_glCopyTextureSubImage2D glCopyTextureSubImage2D;
       |    da_glCopyTextureSubImage3D glCopyTextureSubImage3D;
       |    da_glTextureParameterf glTextureParameterf;
       |    da_glTextureParameterfv glTextureParameterfv;
       |    da_glTextureParameteri glTextureParameteri;
       |    da_glTextureParameterIiv glTextureParameterIiv;
       |    da_glTextureParameterIuiv glTextureParameterIuiv;
       |    da_glTextureParameteriv glTextureParameteriv;
       |    da_glGenerateTextureMipmap glGenerateTextureMipmap;
       |    da_glBindTextureUnit glBindTextureUnit;
       |    da_glGetTextureImage glGetTextureImage;
       |    da_glGetCompressedTextureImage glGetCompressedTextureImage;
       |    da_glGetTextureLevelParameterfv glGetTextureLevelParameterfv;
       |    da_glGetTextureLevelParameteriv glGetTextureLevelParameteriv;
       |    da_glGetTextureParameterfv glGetTextureParameterfv;
       |    da_glGetTextureParameterIiv glGetTextureParameterIiv;
       |    da_glGetTextureParameterIuiv glGetTextureParameterIuiv;
       |    da_glGetTextureParameteriv glGetTextureParameteriv;
       |    da_glCreateVertexArrays glCreateVertexArrays;
       |    da_glDisableVertexArrayAttrib glDisableVertexArrayAttrib;
       |    da_glEnableVertexArrayAttrib glEnableVertexArrayAttrib;
       |    da_glVertexArrayElementBuffer glVertexArrayElementBuffer;
       |    da_glVertexArrayVertexBuffer glVertexArrayVertexBuffer;
       |    da_glVertexArrayVertexBuffers glVertexArrayVertexBuffers;
       |    da_glVertexArrayAttribBinding glVertexArrayAttribBinding;
       |    da_glVertexArrayAttribFormat glVertexArrayAttribFormat;
       |    da_glVertexArrayAttribIFormat glVertexArrayAttribIFormat;
       |    da_glVertexArrayAttribLFormat glVertexArrayAttribLFormat;
       |    da_glVertexArrayBindingDivisor glVertexArrayBindingDivisor;
       |    da_glGetVertexArrayiv glGetVertexArrayiv;
       |    da_glGetVertexArrayIndexediv glGetVertexArrayIndexediv;
       |    da_glGetVertexArrayIndexed64iv glGetVertexArrayIndexed64iv;
       |    da_glCreateSamplers glCreateSamplers;
       |    da_glCreateProgramPipelines glCreateProgramPipelines;
       |    da_glCreateQueries glCreateQueries;
       |    da_glGetQueryBufferObjecti64v glGetQueryBufferObjecti64v;
       |    da_glGetQueryBufferObjectiv glGetQueryBufferObjectiv;
       |    da_glGetQueryBufferObjectui64v glGetQueryBufferObjectui64v;
       |    da_glGetQueryBufferObjectuiv glGetQueryBufferObjectuiv;
       |}
       |
       |private __gshared bool _ARB_direct_state_access;
0000000|@nogc bool ARB_direct_state_access() nothrow @property { return _ARB_direct_state_access; }
       |package void load_ARB_direct_state_access(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glCreateTransformFeedbacks, "glCreateTransformFeedbacks");
0000000|        bindGLFunc(cast(void**)&glTransformFeedbackBufferBase, "glTransformFeedbackBufferBase");
0000000|        bindGLFunc(cast(void**)&glTransformFeedbackBufferRange, "glTransformFeedbackBufferRange");
0000000|        bindGLFunc(cast(void**)&glGetTransformFeedbackiv, "glGetTransformFeedbackiv");
0000000|        bindGLFunc(cast(void**)&glGetTransformFeedbacki_v, "glGetTransformFeedbacki_v");
0000000|        bindGLFunc(cast(void**)&glGetTransformFeedbacki64_v, "glGetTransformFeedbacki64_v");
0000000|        bindGLFunc(cast(void**)&glCreateBuffers, "glCreateBuffers");
0000000|        bindGLFunc(cast(void**)&glNamedBufferStorage, "glNamedBufferStorage");
0000000|        bindGLFunc(cast(void**)&glNamedBufferData, "glNamedBufferData");
0000000|        bindGLFunc(cast(void**)&glNamedBufferSubData, "glNamedBufferSubData");
0000000|        bindGLFunc(cast(void**)&glCopyNamedBufferSubData, "glCopyNamedBufferSubData");
0000000|        bindGLFunc(cast(void**)&glClearNamedBufferData, "glClearNamedBufferData");
0000000|        bindGLFunc(cast(void**)&glClearNamedBufferSubData, "glClearNamedBufferSubData");
0000000|        bindGLFunc(cast(void**)&glMapNamedBuffer, "glMapNamedBuffer");
0000000|        bindGLFunc(cast(void**)&glMapNamedBufferRange, "glMapNamedBufferRange");
0000000|        bindGLFunc(cast(void**)&glUnmapNamedBuffer, "glUnmapNamedBuffer");
0000000|        bindGLFunc(cast(void**)&glFlushMappedNamedBufferRange, "glFlushMappedNamedBufferRange");
0000000|        bindGLFunc(cast(void**)&glGetNamedBufferParameteriv, "glGetNamedBufferParameteriv");
0000000|        bindGLFunc(cast(void**)&glGetNamedBufferParameteri64v, "glGetNamedBufferParameteri64v");
0000000|        bindGLFunc(cast(void**)&glGetNamedBufferPointerv, "glGetNamedBufferPointerv");
0000000|        bindGLFunc(cast(void**)&glGetNamedBufferSubData, "glGetNamedBufferSubData");
0000000|        bindGLFunc(cast(void**)&glCreateFramebuffers, "glCreateFramebuffers");
0000000|        bindGLFunc(cast(void**)&glNamedFramebufferRenderbuffer, "glNamedFramebufferRenderbuffer");
0000000|        bindGLFunc(cast(void**)&glNamedFramebufferParameteri, "glNamedFramebufferParameteri");
0000000|        bindGLFunc(cast(void**)&glNamedFramebufferTexture, "glNamedFramebufferTexture");
0000000|        bindGLFunc(cast(void**)&glNamedFramebufferTextureLayer, "glNamedFramebufferTextureLayer");
0000000|        bindGLFunc(cast(void**)&glNamedFramebufferDrawBuffer, "glNamedFramebufferDrawBuffer");
0000000|        bindGLFunc(cast(void**)&glNamedFramebufferDrawBuffers, "glNamedFramebufferDrawBuffers");
0000000|        bindGLFunc(cast(void**)&glNamedFramebufferReadBuffer, "glNamedFramebufferReadBuffer");
0000000|        bindGLFunc(cast(void**)&glInvalidateNamedFramebufferData, "glInvalidateNamedFramebufferData");
0000000|        bindGLFunc(cast(void**)&glInvalidateNamedFramebufferSubData, "glInvalidateNamedFramebufferSubData");
0000000|        bindGLFunc(cast(void**)&glClearNamedFramebufferiv, "glClearNamedFramebufferiv");
0000000|        bindGLFunc(cast(void**)&glClearNamedFramebufferuiv, "glClearNamedFramebufferuiv");
0000000|        bindGLFunc(cast(void**)&glClearNamedFramebufferfv, "glClearNamedFramebufferfv");
0000000|        bindGLFunc(cast(void**)&glClearNamedFramebufferfi, "glClearNamedFramebufferfi");
0000000|        bindGLFunc(cast(void**)&glBlitNamedFramebuffer, "glBlitNamedFramebuffer");
0000000|        bindGLFunc(cast(void**)&glCheckNamedFramebufferStatus, "glCheckNamedFramebufferStatus");
0000000|        bindGLFunc(cast(void**)&glGetNamedFramebufferParameteriv, "glGetNamedFramebufferParameteriv");
0000000|        bindGLFunc(cast(void**)&glGetNamedFramebufferAttachmentParameteriv, "glGetNamedFramebufferAttachmentParameteriv");
0000000|        bindGLFunc(cast(void**)&glCreateRenderbuffers, "glCreateRenderbuffers");
0000000|        bindGLFunc(cast(void**)&glNamedRenderbufferStorage, "glNamedRenderbufferStorage");
0000000|        bindGLFunc(cast(void**)&glNamedRenderbufferStorageMultisample, "glNamedRenderbufferStorageMultisample");
0000000|        bindGLFunc(cast(void**)&glGetNamedRenderbufferParameteriv, "glGetNamedRenderbufferParameteriv");
0000000|        bindGLFunc(cast(void**)&glCreateTextures, "glCreateTextures");
0000000|        bindGLFunc(cast(void**)&glTextureBuffer, "glTextureBuffer");
0000000|        bindGLFunc(cast(void**)&glTextureBufferRange, "glTextureBufferRange");
0000000|        bindGLFunc(cast(void**)&glTextureStorage1D, "glTextureStorage1D");
0000000|        bindGLFunc(cast(void**)&glTextureStorage2D, "glTextureStorage2D");
0000000|        bindGLFunc(cast(void**)&glTextureStorage3D, "glTextureStorage3D");
0000000|        bindGLFunc(cast(void**)&glTextureStorage2DMultisample, "glTextureStorage2DMultisample");
0000000|        bindGLFunc(cast(void**)&glTextureStorage3DMultisample, "glTextureStorage3DMultisample");
0000000|        bindGLFunc(cast(void**)&glTextureSubImage1D, "glTextureSubImage1D");
0000000|        bindGLFunc(cast(void**)&glTextureSubImage2D, "glTextureSubImage2D");
0000000|        bindGLFunc(cast(void**)&glTextureSubImage3D, "glTextureSubImage3D");
0000000|        bindGLFunc(cast(void**)&glCompressedTextureSubImage1D, "glCompressedTextureSubImage1D");
0000000|        bindGLFunc(cast(void**)&glCompressedTextureSubImage2D, "glCompressedTextureSubImage2D");
0000000|        bindGLFunc(cast(void**)&glCompressedTextureSubImage3D, "glCompressedTextureSubImage3D");
0000000|        bindGLFunc(cast(void**)&glCopyTextureSubImage1D, "glCopyTextureSubImage1D");
0000000|        bindGLFunc(cast(void**)&glCopyTextureSubImage2D, "glCopyTextureSubImage2D");
0000000|        bindGLFunc(cast(void**)&glCopyTextureSubImage3D, "glCopyTextureSubImage3D");
0000000|        bindGLFunc(cast(void**)&glTextureParameterf, "glTextureParameterf");
0000000|        bindGLFunc(cast(void**)&glTextureParameterfv, "glTextureParameterfv");
0000000|        bindGLFunc(cast(void**)&glTextureParameteri, "glTextureParameteri");
0000000|        bindGLFunc(cast(void**)&glTextureParameterIiv, "glTextureParameterIiv");
0000000|        bindGLFunc(cast(void**)&glTextureParameterIuiv, "glTextureParameterIuiv");
0000000|        bindGLFunc(cast(void**)&glTextureParameteriv, "glTextureParameteriv");
0000000|        bindGLFunc(cast(void**)&glGenerateTextureMipmap, "glGenerateTextureMipmap");
0000000|        bindGLFunc(cast(void**)&glBindTextureUnit, "glBindTextureUnit");
0000000|        bindGLFunc(cast(void**)&glGetTextureImage, "glGetTextureImage");
0000000|        bindGLFunc(cast(void**)&glGetCompressedTextureImage, "glGetCompressedTextureImage");
0000000|        bindGLFunc(cast(void**)&glGetTextureLevelParameterfv, "glGetTextureLevelParameterfv");
0000000|        bindGLFunc(cast(void**)&glGetTextureLevelParameteriv, "glGetTextureLevelParameteriv");
0000000|        bindGLFunc(cast(void**)&glGetTextureParameterfv, "glGetTextureParameterfv");
0000000|        bindGLFunc(cast(void**)&glGetTextureParameterIiv, "glGetTextureParameterIiv");
0000000|        bindGLFunc(cast(void**)&glGetTextureParameterIuiv, "glGetTextureParameterIuiv");
0000000|        bindGLFunc(cast(void**)&glGetTextureParameteriv, "glGetTextureParameteriv");
0000000|        bindGLFunc(cast(void**)&glCreateVertexArrays, "glCreateVertexArrays");
0000000|        bindGLFunc(cast(void**)&glDisableVertexArrayAttrib, "glDisableVertexArrayAttrib");
0000000|        bindGLFunc(cast(void**)&glEnableVertexArrayAttrib, "glEnableVertexArrayAttrib");
0000000|        bindGLFunc(cast(void**)&glVertexArrayElementBuffer, "glVertexArrayElementBuffer");
0000000|        bindGLFunc(cast(void**)&glVertexArrayVertexBuffer, "glVertexArrayVertexBuffer");
0000000|        bindGLFunc(cast(void**)&glVertexArrayVertexBuffers, "glVertexArrayVertexBuffers");
0000000|        bindGLFunc(cast(void**)&glVertexArrayAttribBinding, "glVertexArrayAttribBinding");
0000000|        bindGLFunc(cast(void**)&glVertexArrayAttribFormat, "glVertexArrayAttribFormat");
0000000|        bindGLFunc(cast(void**)&glVertexArrayAttribIFormat, "glVertexArrayAttribIFormat");
0000000|        bindGLFunc(cast(void**)&glVertexArrayAttribLFormat, "glVertexArrayAttribLFormat");
0000000|        bindGLFunc(cast(void**)&glVertexArrayBindingDivisor, "glVertexArrayBindingDivisor");
0000000|        bindGLFunc(cast(void**)&glGetVertexArrayiv, "glGetVertexArrayiv");
0000000|        bindGLFunc(cast(void**)&glGetVertexArrayIndexediv, "glGetVertexArrayIndexediv");
0000000|        bindGLFunc(cast(void**)&glGetVertexArrayIndexed64iv, "glGetVertexArrayIndexed64iv");
0000000|        bindGLFunc(cast(void**)&glCreateSamplers, "glCreateSamplers");
0000000|        bindGLFunc(cast(void**)&glCreateProgramPipelines, "glCreateProgramPipelines");
0000000|        bindGLFunc(cast(void**)&glCreateQueries, "glCreateQueries");
0000000|        bindGLFunc(cast(void**)&glGetQueryBufferObjecti64v, "glGetQueryBufferObjecti64v");
0000000|        bindGLFunc(cast(void**)&glGetQueryBufferObjectiv, "glGetQueryBufferObjectiv");
0000000|        bindGLFunc(cast(void**)&glGetQueryBufferObjectui64v, "glGetQueryBufferObjectui64v");
0000000|        bindGLFunc(cast(void**)&glGetQueryBufferObjectuiv, "glGetQueryBufferObjectuiv");
0000000|        _ARB_direct_state_access = true;
       |    } catch(Exception e) {
0000000|        _ARB_direct_state_access = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_get_texture_sub_image
       |extern(System) @nogc nothrow {
       |    alias da_glGetTextureSubImage = void function(GLuint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei,GLenum,GLenum,GLsizei,void*);
       |    alias da_glGetCompressedTextureSubImage = void function(GLuint,GLint,GLint,GLint,GLint,GLsizei,GLsizei,GLsizei,GLsizei,void*);
       |}
       |
       |__gshared {
       |    da_glGetTextureSubImage glGetTextureSubImage;
       |    da_glGetCompressedTextureSubImage glGetCompressedTextureSubImage;
       |}
       |
       |private __gshared bool _ARB_get_texture_sub_image;
0000000|@nogc bool ARB_get_texture_sub_image() nothrow @property { return _ARB_get_texture_sub_image; }
       |package void load_ARB_get_texture_sub_image(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glGetTextureSubImage, "glGetTextureSubImage");
0000000|        bindGLFunc(cast(void**)&glGetCompressedTextureSubImage, "glGetCompressedTextureSubImage");
0000000|        _ARB_get_texture_sub_image = true;
       |    } catch(Exception e) {
0000000|        _ARB_get_texture_sub_image = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// KHR_robustness
       |extern(System) @nogc nothrow {
       |    alias da_glGetGraphicsResetStatus = GLenum function();
       |    alias da_glReadnPixels = void function(GLint,GLint,GLsizei,GLsizei,GLenum,GLenum,GLsizei,void*);
       |    alias da_glGetnUniformfv = void function(GLuint,GLint,GLsizei,GLfloat*);
       |    alias da_glGetnUniformiv = void function(GLuint,GLint,GLsizei,GLint*);
       |    alias da_glGetnUniformuiv = void function(GLuint,GLint,GLsizei,GLuint*);
       |}
       |
       |__gshared {
       |    da_glGetGraphicsResetStatus glGetGraphicsResetStatus;
       |    da_glReadnPixels glReadnPixels;
       |    da_glGetnUniformfv glGetnUniformfv;
       |    da_glGetnUniformiv glGetnUniformiv;
       |    da_glGetnUniformuiv glGetnUniformuiv;
       |}
       |
       |private __gshared bool _KHR_robustness;
0000000|@nogc bool KHR_robustness() nothrow @property { return _KHR_robustness; }
       |package void load_KHR_robustness(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glGetGraphicsResetStatus, "glGetGraphicsResetStatus");
0000000|        bindGLFunc(cast(void**)&glReadnPixels, "glReadnPixels");
0000000|        bindGLFunc(cast(void**)&glGetnUniformfv, "glGetnUniformfv");
0000000|        bindGLFunc(cast(void**)&glGetnUniformiv, "glGetnUniformiv");
0000000|        bindGLFunc(cast(void**)&glGetnUniformuiv, "glGetnUniformuiv");
0000000|        _KHR_robustness = true;
       |    } catch(Exception e) {
0000000|        _KHR_robustness = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |// ARB_shader_texture_image_samples
       |private __gshared bool _ARB_shader_texture_image_samples;
0000000|@nogc bool ARB_shader_texture_image_samples() nothrow @property { return _ARB_shader_texture_image_samples; }
       |
       |// ARB_texture_barrier
       |extern(System) @nogc nothrow alias da_glTextureBarrier = void function();
       |__gshared da_glTextureBarrier glTextureBarrier;
       |private __gshared bool _ARB_texture_barrier;
0000000|@nogc bool ARB_texture_barrier() nothrow @property { return _ARB_texture_barrier; }
       |package void load_ARB_texture_barrier(bool doThrow = false) {
       |    try {
0000000|        bindGLFunc(cast(void**)&glTextureBarrier, "glTextureBarrier");
0000000|        _ARB_texture_barrier = true;
       |    } catch(Exception e) {
0000000|        _ARB_texture_barrier = false;
0000000|        if(doThrow) throw e;
       |    }
       |}
       |
       |package void loadARB(GLVersion glversion)
       |{
0000000|    if(glversion  < GLVersion.GL30) {
0000000|        if(isExtSupported(glversion, "GL_ARB_framebuffer_object")) load_ARB_framebuffer_object();
0000000|        if(isExtSupported(glversion, "GL_ARB_map_buffer_range")) load_ARB_map_buffer_range();
0000000|        if(isExtSupported(glversion, "GL_ARB_vertex_array_object")) load_ARB_vertex_array_object();
       |    }
       |
0000000|    if(glversion < GLVersion.GL31) {
0000000|        if(isExtSupported(glversion, "GL_ARB_copy_buffer")) load_ARB_copy_buffer();
0000000|        if(isExtSupported(glversion, "GL_ARB_uniform_buffer_object")) load_ARB_uniform_buffer_object();
       |    }
       |
0000000|    if(glversion < GLVersion.GL32) {
0000000|        if(isExtSupported(glversion, "GL_ARB_draw_elements_base_vertex")) load_ARB_draw_elements_base_vertex();
0000000|        if(isExtSupported(glversion, "GL_ARB_provoking_vertex")) load_ARB_provoking_vertex();
0000000|        if(isExtSupported(glversion, "GL_ARB_sync")) load_ARB_sync();
0000000|        if(isExtSupported(glversion, "GL_ARB_texture_multisample")) load_ARB_texture_multisample();
       |    }
       |
0000000|    if(glversion < GLVersion.GL33) {
0000000|        if(isExtSupported(glversion, "GL_ARB_blend_func_extended")) load_ARB_blend_func_extended();
0000000|        if(isExtSupported(glversion, "GL_ARB_sampler_objects")) load_ARB_sampler_objects();
0000000|        if(isExtSupported(glversion, "GL_ARB_timer_query")) load_ARB_timer_query();
0000000|        if(isExtSupported(glversion, "GL_ARB_vertex_type_2_10_10_10_rev")) load_ARB_vertex_type_2_10_10_10_rev();
       |    }
       |
0000000|    if(glversion < GLVersion.GL40) {
0000000|        if(isExtSupported(glversion, "GL_ARB_draw_buffers_blend")) load_ARB_draw_buffers_blend();
0000000|        if(isExtSupported(glversion, "GL_ARB_draw_indirect")) load_ARB_draw_indirect();
0000000|        if(isExtSupported(glversion, "GL_ARB_gpu_shader_fp64")) load_ARB_gpu_shader_fp64();
0000000|        if(isExtSupported(glversion, "GL_ARB_sample_shading")) load_ARB_sample_shading();
0000000|        if(isExtSupported(glversion, "GL_ARB_shader_subroutine")) load_ARB_shader_subroutine();
0000000|        if(isExtSupported(glversion, "GL_ARB_tessellation_shader")) load_ARB_tessellation_shader();
0000000|        if(isExtSupported(glversion, "GL_ARB_transform_feedback2")) load_ARB_transform_feedback2();
0000000|        if(isExtSupported(glversion, "GL_ARB_transform_feedback3")) load_ARB_transform_feedback3();
       |    }
       |
0000000|    if(glversion < GLVersion.GL41) {
0000000|        if(isExtSupported(glversion, "GL_ARB_ES2_compatibility")) load_ARB_ES2_compatibility();
0000000|        if(isExtSupported(glversion, "GL_ARB_get_program_binary")) load_ARB_get_program_binary();
0000000|        if(isExtSupported(glversion, "GL_ARB_separate_shader_objects")) load_ARB_separate_shader_objects();
0000000|        if(isExtSupported(glversion, "GL_ARB_vertex_attrib_64bit")) load_ARB_vertex_attrib_64bit();
0000000|        if(isExtSupported(glversion, "GL_ARB_viewport_array")) load_ARB_viewport_array();
       |    }
       |
0000000|    if(glversion < GLVersion.GL42) {
0000000|        if(isExtSupported(glversion, "GL_ARB_base_instance")) load_ARB_base_instance();
0000000|        if(isExtSupported(glversion, "GL_ARB_transform_feedback_instanced")) load_ARB_transform_feedback_instanced();
0000000|        if(isExtSupported(glversion, "GL_ARB_internalformat_query")) load_ARB_internalformat_query();
0000000|        if(isExtSupported(glversion, "GL_ARB_shader_atomic_counters")) load_ARB_shader_atomic_counters();
0000000|        if(isExtSupported(glversion, "GL_ARB_shader_image_load_store")) load_ARB_shader_image_load_store();
0000000|        if(isExtSupported(glversion, "GL_ARB_texture_storage")) load_ARB_texture_storage(glversion);
       |    }
       |
0000000|    if(glversion < GLVersion.GL43) {
0000000|        if(isExtSupported(glversion, "GL_ARB_clear_buffer_object")) load_ARB_clear_buffer_object();
0000000|        if(isExtSupported(glversion, "GL_ARB_copy_image")) load_ARB_copy_image();
0000000|        if(isExtSupported(glversion, "GL_ARB_compute_shader")) load_ARB_compute_shader();
0000000|        if(isExtSupported(glversion, "GL_KHR_debug")) load_KHR_debug();
0000000|        if(isExtSupported(glversion, "GL_ARB_framebuffer_no_attachments")) load_ARB_framebuffer_no_attachments();
0000000|        if(isExtSupported(glversion, "GL_ARB_internalformat_query2")) load_ARB_internalformat_query2();
0000000|        if(isExtSupported(glversion,"GL_ARB_invalidate_subdata")) load_ARB_invalidate_subdata();
0000000|        if(isExtSupported(glversion,"GL_ARB_multi_draw_indirect")) load_ARB_multi_draw_indirect();
0000000|        if(isExtSupported(glversion, "GL_ARB_program_interface_query")) load_ARB_program_interface_query();
0000000|        if(isExtSupported(glversion, "GL_ARB_shader_storage_buffer_object")) load_ARB_shader_storage_buffer_object();
0000000|        if(isExtSupported(glversion, "GL_ARB_texture_buffer_range")) load_ARB_texture_buffer_range();
0000000|        if(isExtSupported(glversion, "GL_ARB_texture_storage_multisample")) load_ARB_texture_storage_multisample();
0000000|        if(isExtSupported(glversion,"GL_ARB_texture_view")) load_ARB_texture_view();
0000000|        if(isExtSupported(glversion, "GL_ARB_vertex_attrib_binding")) load_ARB_vertex_attrib_binding();
       |    }
       |
0000000|    if(glversion < GLVersion.GL44) {
0000000|        if(isExtSupported(glversion, "GL_ARB_buffer_storage")) load_ARB_buffer_storage(glversion);
0000000|        if(isExtSupported(glversion, "GL_ARB_clear_texture")) load_ARB_clear_texture();
0000000|        if(isExtSupported(glversion, "GL_ARB_multi_bind")) load_ARB_multi_bind();
       |    }
       |
0000000|    if(glversion < GLVersion.GL45) {
0000000|        if(isExtSupported(glversion, "GL_ARB_clip_control")) load_ARB_clip_control();
0000000|        if(isExtSupported(glversion, "GL_ARB_ES3_1_compatibility")) load_ARB_ES3_1_compatibility();
0000000|        if(isExtSupported(glversion, "GL_ARB_direct_state_access")) load_ARB_direct_state_access();
0000000|        if(isExtSupported(glversion, "GL_ARB_get_texture_sub_image")) load_ARB_get_texture_sub_image();
0000000|        if(isExtSupported(glversion, "GL_KHR_robustness")) load_KHR_robustness();
0000000|        if(isExtSupported(glversion, "GL_ARB_texture_barrier")) load_ARB_texture_barrier();
       |    }
       |
0000000|    if(isExtSupported(glversion, "GL_ARB_geometry_shader4")) load_ARB_geometry_shader4();
0000000|    if(isExtSupported(glversion, "GL_ARB_debug_output")) load_ARB_debug_output();
0000000|    _ARB_vertex_array_bgra = isExtSupported(glversion, "GL_ARB_vertex_array_bgra");
0000000|    _ARB_fragment_coord_conventions = isExtSupported(glversion, "GL_ARB_fragment_coord_conventions");
0000000|    _ARB_seamless_cube_map = isExtSupported(glversion, "GL_ARB_seamless_cube_map");
0000000|    _ARB_depth_buffer_float = isExtSupported(glversion, "GL_ARB_depth_buffer_float");
0000000|    _ARB_framebuffer_sRGB = isExtSupported(glversion, "GL_ARB_framebuffer_sRGB");
0000000|    _ARB_half_float_vertex = isExtSupported(glversion, "GL_ARB_half_float_vertex");
0000000|    _ARB_imaging = isExtSupported(glversion, "GL_ARB_imaging");
0000000|    _ARB_texture_compression_rgtc = isExtSupported(glversion, "GL_ARB_texture_compression_rgtc");
0000000|    _ARB_texture_rg = isExtSupported(glversion, "GL_ARB_texture_rg");
0000000|    _ARB_depth_clamp = isExtSupported(glversion, "GL_ARB_depth_clamp");
0000000|    _ARB_explicit_attrib_location = isExtSupported(glversion, "GL_ARB_explicit_attrib_location");
0000000|    _ARB_occlusion_query2 = isExtSupported(glversion, "GL_ARB_occlusion_query2");
0000000|    _ARB_shader_bit_encoding = isExtSupported(glversion, "GL_ARB_shader_bit_encoding");
0000000|    _ARB_texture_rgb10_a2ui = isExtSupported(glversion, "GL_ARB_texture_rgb10_a2ui");
0000000|    _ARB_texture_swizzle = isExtSupported(glversion, "GL_ARB_texture_swizzle");
0000000|    _ARB_texture_query_lod = isExtSupported(glversion, "GL_ARB_texture_query_lod");
0000000|    _ARB_gpu_shader5 = isExtSupported(glversion, "GL_ARB_gpu_shader5");
0000000|    _ARB_texture_buffer_object_rgb32 = isExtSupported(glversion, "GL_ARB_texture_buffer_object_rgb32");
0000000|    _ARB_texture_cube_map_array = isExtSupported(glversion, "GL_ARB_texture_cube_map_array");
0000000|    _ARB_texture_gather = isExtSupported(glversion, "GL_ARB_texture_gather");
0000000|    _ARB_shader_precision = isExtSupported(glversion, "GL_ARB_shader_precision");
0000000|    _ARB_texture_compression_bptc = isExtSupported(glversion, "GL__ARB_texture_compression_bptc");
0000000|    _ARB_shading_language_420pack = isExtSupported(glversion, "GL_ARB_shading_language_420pack");
0000000|    _ARB_compressed_texture_pixel_storage = isExtSupported(glversion, "GL_ARB_compressed_texture_pixel_storage");
0000000|    _ARB_conservative_depth = isExtSupported(glversion, "GL_ARB_conservative_depth");
0000000|    _ARB_map_buffer_alignment = isExtSupported(glversion, "GL_ARB_map_buffer_alignment");
0000000|    _ARB_shading_language_packing = isExtSupported(glversion, "GL_ARB_shading_language_packing");
0000000|    _ARB_array_of_arrays = isExtSupported(glversion, "GL_ARB_array_of_arrays");
0000000|    _ARB_fragment_layer_viewport = isExtSupported(glversion, "GL_ARB_fragment_layer_viewport");
0000000|    _ARB_shader_image_size = isExtSupported(glversion, "GL_ARB_shader_image_size");
0000000|    _ARB_ES3_compatibility = isExtSupported(glversion, "GL_ARB_ES3_compatibility");
0000000|    _ARB_copy_image = isExtSupported(glversion, "GL_ARB_copy_image");
0000000|    _ARB_explicit_uniform_location = isExtSupported(glversion, "GL_ARB_explicit_uniform_location");
0000000|    _ARB_robust_buffer_access_behavior = isExtSupported(glversion, "GL_ARB_robust_buffer_access_behavior");
0000000|    _ARB_stencil_texturing = isExtSupported(glversion, "GL_ARB_stencil_texturing");
0000000|    _ARB_texture_query_levels = isExtSupported(glversion, "GL_ARB_texture_query_levels");
0000000|    _ARB_enhanced_layouts = isExtSupported(glversion, "GL_ARB_enhanced_layouts");
0000000|    _ARB_query_buffer_object = isExtSupported(glversion, "GL_ARB_query_buffer_object");
0000000|    _ARB_texture_mirror_clamp_to_edge = isExtSupported(glversion, "GL_ARB_texture_mirror_clamp_to_edge");
0000000|    _ARB_texture_stencil8 = isExtSupported(glversion, "GL_ARB_texture_stencil8");
0000000|    _ARB_vertex_type_10f_11f_11f_rev = isExtSupported(glversion, "GL_ARB_vertex_type_10f_11f_11f_rev");
0000000|    _ARB_cull_distance = isExtSupported(glversion, "GL_ARB_cull_distance");
0000000|    _ARB_conditional_render_inverted = isExtSupported(glversion, "GL_ARB_conditional_render_inverted");
0000000|    _KHR_context_flush_control = isExtSupported(glversion, "GL_KHR_context_flush_control");
0000000|    _ARB_derivative_control = isExtSupported(glversion, "GL_ARB_derivative_control");
0000000|    _ARB_shader_texture_image_samples = isExtSupported(glversion, "GL_ARB_shader_texture_image_samples");
       |}
../../.dub/packages/derelict-gl3-1.0.22/source/derelict/opengl3/arb.d is 0% covered
